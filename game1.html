<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.5, user-scalable=yes" />
    <title>컬러 슈터</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pretendard@1.3.9/dist/web/static/pretendard.min.css">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            font-family: 'Pretendard', Arial, sans-serif;
            background: linear-gradient(135deg, #e0f2fe 0%, #ddd6fe 50%, #fce7f3 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease-in-out infinite;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            overflow: hidden;
            position: relative;
        }
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        .sparkle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #93c5fd, transparent);
            border-radius: 50%;
            animation: sparkleAnim var(--duration) ease-in-out infinite;
            opacity: 0;
            box-shadow: 0 0 10px rgba(147, 197, 253, 0.8);
            pointer-events: none;
        }
        @keyframes sparkleAnim {
            0%, 100% { opacity: 0; transform: scale(0.5) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.5) rotate(180deg); }
        }
        #intro {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(14, 165, 233, 0.2);
            max-width: 90vw;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 10;
            position: relative;
            border: 3px solid rgba(147, 197, 253, 0.5);
        }
        #intro h1 {
            margin: 0;
            font-size: 36px;
            color: #0284c7;
            font-weight: 800;
        }
        #intro p {
            margin: 0;
            font-size: 18px;
            color: #64748b;
            line-height: 1.6;
        }
        .game-instructions {
            background: rgba(240, 249, 255, 0.8);
            border-radius: 15px;
            padding: 20px;
            margin: 10px 0;
            text-align: left;
            font-size: 14px;
            color: #0369a1;
            line-height: 1.5;
            border: 2px solid rgba(147, 197, 253, 0.3);
        }
        .game-instructions h3 {
            margin: 0 0 10px 0;
            color: #0284c7;
            font-size: 16px;
        }
        .intro-btn {
            background: linear-gradient(135deg, #38bdf8, #818cf8);
            color: #fff;
            border: none;
            padding: 16px 32px;
            border-radius: 18px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 700;
            transition: all 0.3s ease;
            touch-action: manipulation;
            box-shadow: 0 8px 20px rgba(56, 189, 248, 0.4);
            position: relative;
            overflow: hidden;
        }
        .intro-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        .intro-btn:hover::before {
            left: 100%;
        }
        .intro-btn:active {
            transform: scale(0.95);
        }
        .intro-btn.btn-home {
            background: linear-gradient(135deg, #94a3b8, #64748b);
            box-shadow: 0 8px 20px rgba(100, 116, 139, 0.3);
        }
        .game-container {
            display: none;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 8px;
            box-shadow: 0 20px 60px rgba(14, 165, 233, 0.2);
            width: 100vw;
            max-width: 95vw;
            height: 100vh;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;
            align-items: center;
            overflow: hidden;
            touch-action: manipulation;
            z-index: 10;
            position: relative;
            border: 3px solid rgba(147, 197, 253, 0.5);
        }
        .score-board {
            text-align: center;
            margin-bottom: 8px;
            font-size: 20px;
            font-weight: 700;
            color: #0284c7;
            background: rgba(240, 249, 255, 0.8);
            padding: 10px 20px;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(56, 189, 248, 0.2);
            border: 2px solid rgba(147, 197, 253, 0.3);
        }
        .stage-progress {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #0369a1;
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(240, 249, 255, 0.9);
            padding: 8px 0;
            border-radius: 15px;
            border: 2px solid rgba(147, 197, 253, 0.3);
        }
        .stage-indicator {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #94a3b8;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            color: #0369a1;
            position: relative;
            transition: all 0.3s ease;
        }
        .stage-indicator.cleared {
            background: linear-gradient(135deg, #2dd4bf, #14b8a6);
            border-color: #28a745;
            color: #fff;
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }
        .stage-indicator.current {
            background: linear-gradient(135deg, #007bff, #0056b3);
            border-color: #007bff;
            color: #fff;
            transform: scale(1.2);
            box-shadow: 0 6px 16px rgba(0, 123, 255, 0.4);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1.2); }
            50% { transform: scale(1.3); }
        }
        .stage-indicator:not(:last-child)::after {
            content: '-';
            position: absolute;
            right: -12px;
            color: #cbd5e1;
            font-size: 12px;
        }
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            justify-content: space-evenly;
            align-items: center;
            width: 100%;
            overflow: hidden;
        }
        .target-area {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 3px solid rgba(147, 197, 253, 0.5);
            border-radius: 20px;
            padding: 0px;
            height: 33vh;
            width: 100%;
            position: relative;
            overflow: hidden;
            margin-bottom: 8px;
            box-shadow: inset 0 2px 8px rgba(56, 189, 248, 0.1), 0 4px 12px rgba(56, 189, 248, 0.2);
        }
        .target-title {
            text-align: center;
            font-weight: 700;
            margin-bottom: 8px;
            color: #0284c7;
            font-size: 16px;
        }
        .target-lanes {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: flex-end;
            height: calc(100% - 32px);
            max-height: calc(33vh - 32px);
            overflow: hidden;
            position: relative;
        }
        .target-lanes::after {
            content: '';
            position: absolute;
            top: -40px;
            left: 0;
            right: 0;
            height: 40px;
            background: transparent;
            pointer-events: none;
            z-index: 5;
        }
        .target-lane {
            width: 60px;
            display: flex;
            flex-direction: column-reverse;
            gap: 4px;
            height: 100%;
            align-items: flex-end;
            padding-bottom: 0px;
            max-height: calc(33vh - 32px);
            overflow: visible;
        }
        .target-block {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            border: 3px solid rgba(255,255,255,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            position: relative;
            box-sizing: border-box;
            transition: all 0.3s ease;
            flex-shrink: 0;
            background: linear-gradient(135deg, var(--color-start), var(--color-end));
            box-shadow: 0 4px 12px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.4);
        }
        .target-block.attackable {
            border-color: #fbbf24;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.6), 0 4px 12px rgba(0,0,0,0.2);
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { box-shadow: 0 0 20px rgba(251, 191, 36, 0.6), 0 4px 12px rgba(0,0,0,0.2); }
            to { box-shadow: 0 0 30px rgba(251, 191, 36, 0.8), 0 6px 16px rgba(0,0,0,0.3); }
        }
        .block-number {
            font-size: 20px;
            line-height: 1;
        }
        .queue-area {
            background: linear-gradient(135deg, #bae6fd 0%, #c4b5fd 100%);
            border: 3px solid rgba(147, 197, 253, 0.5);
            border-radius: 20px;
            padding: 12px;
            display: flex;
            justify-content: center;
            gap: 12px;
            align-items: center;
            height: 10vh;
            width: 100%;
            position: relative;
            z-index: 30;
            box-shadow: inset 0 2px 8px rgba(56, 189, 248, 0.2), 0 4px 12px rgba(56, 189, 248, 0.2);
        }
        .queue-slot {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            border: 3px dashed rgba(147, 197, 253, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: rgba(3, 105, 161, 0.6);
            position: relative;
            box-sizing: border-box;
            background: rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            font-weight: 600;
        }
        .queue-block {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            border: 3px solid rgba(255,255,255,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            position: relative;
            box-sizing: border-box;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, var(--color-start), var(--color-end));
            box-shadow: 0 4px 12px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .queue-block.added {
            animation: slideIn 0.4s ease-out;
        }
        @keyframes slideIn {
            0% { opacity: 0; transform: scale(0.6) translateY(-20px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        .selection-area {
            background: linear-gradient(135deg, #bae6fd 0%, #c4b5fd 100%);
            border-radius: 20px;
            padding: 12px;
            color: #0369a1;
            height: 35vh;
            width: 100%;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 8px rgba(56, 189, 248, 0.2), 0 4px 12px rgba(56, 189, 248, 0.2);
            border: 3px solid rgba(147, 197, 253, 0.5);
        }
        .selection-title {
            text-align: center;
            font-weight: 700;
            margin-bottom: 8px;
            font-size: 16px;
            color: #0284c7;
        }
        .stacks-container {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: flex-start;
            padding-top: 10px;
            height: calc(100% - 28px);
            max-height: calc(35vh - 28px);
            overflow: hidden;
            position: relative;
            margin-top: 20px;
        }
        .stacks-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: transparent;
            pointer-events: none;
            z-index: 10;
        }
        .stack {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
            height: 100%;
            max-height: calc(35vh - 28px);
            width: 60px;
            overflow: visible;
        }
        .stack-block {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            border: 3px solid rgba(255,255,255,0.5);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            position: relative;
            box-sizing: border-box;
            z-index: 10;
            flex-shrink: 0;
            touch-action: manipulation;
            background: linear-gradient(135deg, var(--color-start), var(--color-end));
            box-shadow: 0 4px 12px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .stack-block.top-block {
            border-color: #10b981;
            box-shadow: 0 0 20px rgba(16,204,113,0.6), 0 4px 12px rgba(0,0,0,0.3);
            cursor: pointer;
            transform: translateY(-4px);
            animation: breathe 3s ease-in-out infinite;
        }
        @keyframes breathe {
            0%, 100% { transform: translateY(-4px); }
            50% { transform: translateY(-8px); }
        }
        .stack-block.top-block:active {
            transform: scale(0.9) translateY(-4px);
        }
        .stack-block:not(.top-block) {
            opacity: 0.7;
            cursor: not-allowed;
        }
        .red {
            --color-start: #fca5a5;
            --color-end: #f87171;
        }
        .blue {
            --color-start: #93c5fd;
            --color-end: #60a5fa;
        }
        .green {
            --color-start: #86efac;
            --color-end: #4ade80;
        }
        .yellow {
            --color-start: #fde047;
            --color-end: #facc15;
            color: #713f12 !important;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5) !important;
        }
        .purple {
            --color-start: #c4b5fd;
            --color-end: #a78bfa;
        }
        .shooting-particle {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            z-index: 2500;
            pointer-events: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.2), 0 0 20px var(--particle-color);
            background: radial-gradient(circle, var(--particle-color), var(--particle-color-dark));
        }
        .damage-text {
            position: fixed;
            color: #f87171;
            font-weight: 700;
            font-size: 18px;
            z-index: 2001;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
        }
        @keyframes damageFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            50% {
                transform: translateY(-20px) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(0.8);
            }
        }
        .game-controls {
    text-align: center;
    padding: 8px;
    background: rgba(240, 249, 255, 0.9);
    position: sticky;
    bottom: 0;
    z-index: 100;
    width: 100%;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(147, 197, 253, 0.3);
    padding-bottom: calc(8px + env(safe-area-inset-bottom));
}
        .btn {
            color: #fff;
            border: none;
            padding: 8px 30px;
            margin: 5px;
            border-radius: 8px;
            background: linear-gradient(145deg, #60a5fa, #93c5fd);
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
        }
        .btn-home {
            background: linear-gradient(135deg, #94a3b8, #64748b);
        }
        .message {
            text-align: center;
            margin-top: 8px;
            font-weight: 700;
            font-size: 16px;
            min-height: 24px;
            width: 100%;
            color: #0284c7;
        }
        .success {
            color: #10b981;
            animation: successPulse 0.6s ease-out;
        }
        .warning {
            color: #f59e0b;
            animation: warningShake 0.5s ease-out;
        }
        .error {
            color: #f87171;
            animation: errorShake 0.5s ease-out;
        }
        @keyframes successPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        @keyframes warningShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }
        .modal-backdrop {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(186, 230, 253, 0.3);
            backdrop-filter: blur(15px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            animation: fadeIn 0.3s ease-out;
            padding-top: env(safe-area-inset-top); /* 모바일 safe-area */
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            overflow: hidden; /* 스크롤 방지 */
            -webkit-overflow-scrolling: touch; /* iOS 부드러운 터치 */
        }
        .modal-backdrop.show {
            display: flex;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(30px);
            padding: 30px;
            border-radius: 25px;
            width: 90vw;
            max-width: 350px; /* 데스크탑에서 너무 넓지 않게 제한 */
            text-align: center;
            box-shadow: 0 20px 60px rgba(14, 165, 233, 0.3);
            font-family: 'Pretendard', Arial, sans-serif;
            border: 3px solid rgba(147, 197, 253, 0.5);
            animation: modalBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 250px; /* 모바일 화면에 맞춤 */
        }
        @keyframes modalBounce {
            0% {
                transform: scale(0.5) translateY(50px);
                opacity: 0;
            }
            70% {
                transform: scale(1.05) translateY(-10px);
            }
            100% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        .modal h2 {
            margin: 8px 0 16px 0;
            font-size: 24px;
            color: #0284c7;
            font-weight: 800;
        }
        .modal p {
            margin: 12px 0 20px 0;
            font-size: 16px;
            color: #64748b;
            line-height: 1.5;
        }
        .modal-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: center;
        }
        @media (max-width: 768px) {
            #intro {
                padding: 30px 20px;
            }
            #intro h1 {
                font-size: 28px;
            }
            .game-container {
                padding: 4px;
                max-width: 100vw;
                max-height: 100vh;
                justify-content: space-evenly;
            }
            .game-area {
                gap: 12px;
            }
            .score-board {
                font-size: 16px;
                margin-bottom: 4px;
                padding: 8px 16px;
            }
            .stage-progress {
                gap: 6px;
                margin-bottom: 4px;
                font-size: 10px;
                padding: 4px 0;
            }
            .stage-indicator {
                width: 20px;
                height: 20px;
                font-size: 10px;
            }
            .stage-indicator:not(:last-child)::after {
                right: -9px;
                font-size: 10px;
            }
            .target-area {
                height: 38vh;
                padding: 8px;
                margin-bottom: 8px;
            }
            .target-lanes {
                max-height: calc(38vh - 28px);
                gap: 8px;
            }
            .target-lane {
                width: 50px;
                max-height: calc(38vh - 28px);
            }
            .target-block {
                width: 50px;
                height: 50px;
                border-radius: 10px;
            }
            .queue-area {
                height: 12vh;
                padding: 8px;
                gap: 8px;
            }
            .queue-slot, .queue-block {
                width: 50px;
                height: 50px;
                border-radius: 10px;
            }
            .selection-area {
                height: 38vh;
                padding: 8px;
            }
            .stacks-container {
                max-height: calc(38vh - 24px);
                gap: 8px;
                margin-top: 20px;
            }
            .stack {
                max-height: calc(38vh - 24px);
                width: 50px;
            }
            .stack-block {
                width: 50px;
                height: 50px;
                border-radius: 10px;
            }
            .block-number {
                font-size: 16px;
            }
        }
        @media (max-height: 600px) {
            .game-container {
                padding: 4px;
                max-height: 100vh;
                justify-content: space-evenly;
            }
            .game-area {
                gap: 8px;
            }
            .target-area {
                height: 35vh;
                padding: 6px;
                margin-bottom: 6px;
            }
            .selection-area {
                height: 35vh;
                padding: 6px;
            }
            .queue-area {
                height: 10vh;
                padding: 6px;
                gap: 6px;
            }
            .target-lanes {
                max-height: calc(35vh - 20px);
                gap: 6px;
            }
            .stacks-container {
                max-height: calc(35vh - 20px);
                gap: 6px;
                margin-top: 20px;
            }
            .target-lane {
                max-height: calc(35vh - 20px);
                width: 45px;
            }
            .stack {
                max-height: calc(35vh - 20px);
                width: 45px;
            }
            .target-block, .queue-slot, .queue-block, .stack-block {
                width: 45px;
                height: 45px;
                border-radius: 8px;
            }
            .block-number {
                font-size: 14px;
            }
            .target-title, .selection-title {
                font-size: 12px;
                margin-bottom: 4px;
            }
            .btn {
                font-size: 12px;
                padding: 8px 24px;
            }
            .score-board {
                font-size: 14px;
                margin-bottom: 4px;
                padding: 6px 12px;
            }
            .message {
                font-size: 12px;
                margin-top: 4px;
            }
            .modal h2 {
                font-size: 18px;
            }
            .modal p {
                font-size: 12px;
            }
            .damage-text {
                font-size: 14px;
            }
            .stage-progress {
                gap: 4px;
                margin-bottom: 4px;
                font-size: 8px;
            }
            .stage-indicator {
                width: 18px;
                height: 18px;
                font-size: 8px;
            }
            .stage-indicator:not(:last-child)::after {
                right: -8px;
                font-size: 8px;
            }
            .shooting-particle {
                width: 14px;
                height: 14px;
            }
        }
        @media (orientation: landscape) and (max-height: 500px) {
            .game-container {
                padding: 2px;
                justify-content: space-evenly;
            }
            .game-area {
                gap: 6px;
            }
            .target-area {
                height: 32vh;
                padding: 4px;
                margin-bottom: 4px;
            }
            .selection-area {
                height: 32vh;
                padding: 4px;
            }
            .queue-area {
                height: 8vh;
                padding: 4px;
                gap: 4px;
            }
            .target-lanes {
                max-height: calc(32vh - 16px);
            }
            .stacks-container {
                max-height: calc(32vh - 16px);
                margin-top: 20px;
            }
            .target-lane {
                max-height: calc(32vh - 16px);
            }
            .stack {
                max-height: calc(32vh - 16px);
            }
        }
    </style>
</head>
<body>
    <div id="intro">
        <h1>🎯 컬러 슈터</h1>
        <p>색상을 매칭하여 타겟 블록을 모두 제거하세요!</p>
        <div class="game-instructions">
            <h3>📖 게임 방법</h3>
            <p>• 하단 블록에서 상단 블록만 터치 가능</p>
            <p>• 선택한 블록이 가운데 대기열에 추가됩니다</p>
            <p>• 같은 색상의 타겟이 있으면 자동으로 공격</p>
            <p>• 모든 타겟을 제거하면 다음 스테이지!</p>
        </div>
        <button class="intro-btn" id="startGameBtn">🚀 게임 시작</button>
        <button class="intro-btn btn-home" id="goHomeBtn">🏠 홈으로</button>
    </div>
    <div class="game-container" id="gameContainer">
        <div class="score-board">
            <span>🎯 스테이지: <span id="stage">1</span></span>
            <span style="margin-left: 20px;">⭐ 점수: <span id="score">0</span></span>
            <span style="margin-left: 20px;">🎨 색상: <span id="colorCount">3</span></span>
        </div>
        <div class="stage-progress" id="stageProgress"></div>
        <div class="game-area">
            <div class="target-area">
                <div class="target-title">🎯 목표 블록</div>
                <div class="target-lanes" id="targetLanes"></div>
            </div>
            <div class="queue-area" id="queueArea"></div>
            <div class="selection-area">
                <div class="selection-title">🎮 블록 선택</div>
                <div class="stacks-container" id="stacksContainer"></div>
            </div>
        </div>
        <div class="game-controls">
            <button class="btn btn-retry" id="resetGameBtn">🔄 다시 시작</button>
            <button class="btn btn-home" id="goHomeBtn2">🏠 홈으로</button>
        </div>
        <div class="message" id="message"></div>
    </div>
    <div id="modalRoot"></div>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
        import { getDatabase, ref, push, query, orderByChild, limitToLast, get } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js";
        const firebaseConfig = {
            apiKey: "AIzaSyC-M1czGNwh3-xMLHgmEdVmfbHZAmQioiQ",
            authDomain: "gukhyeon-ce3ba.firebaseapp.com",
            databaseURL: "https://gukhyeon-ce3ba-default-rtdb.firebaseio.com",
            projectId: "gukhyeon-ce3ba",
            storageBucket: "gukhyeon-ce3ba.firebasestorage.app",
            messagingSenderId: "751956972723",
            appId: "1:751956972723:web:cedb2e5f483529732e8cc6",
            measurementId: "G-JBBLJNDGY1"
        };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        let playerName = localStorage.getItem('playerName') || 'Guest';
        function createBackgroundEffects() {
            for (let i = 0; i < 30; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                sparkle.style.left = `${Math.random() * 100}%`;
                sparkle.style.top = `${Math.random() * 100}%`;
                sparkle.style.setProperty('--duration', `${Math.random() * 3 + 2}s`);
                sparkle.style.animationDelay = `${Math.random() * 3}s`;
                document.body.appendChild(sparkle);
            }
        }
        class ColorShooterGame {
            constructor() {
                this.fullColorPool = ['red', 'blue', 'green', 'yellow', 'purple'];
                this.stage = 1;
                this.score = 0;
                this.clearedStages = new Set();
                this.stageConfig = {
                    1: { colors: 2, queueSlots: 3, lanes: 3, blocksPerLane: 3, numberRange: [15, 30, 45] },
                    2: { colors: 3, queueSlots: 3, lanes: 3, blocksPerLane: 3, numberRange: [15, 30, 45] },
                    3: { colors: 3, queueSlots: 3, lanes: 3, blocksPerLane: 3, numberRange: [15, 30, 45] },
                    4: { colors: 3, queueSlots: 3, lanes: 3, blocksPerLane: 4, numberRange: [15, 30, 45, 60] },
                    5: { colors: 4, queueSlots: 3, lanes: 3, blocksPerLane: 4, numberRange: [15, 30, 45, 60] },
                    6: { colors: 4, queueSlots: 4, lanes: 4, blocksPerLane: 5, numberRange: [15, 30, 45, 60] },
                    7: { colors: 4, queueSlots: 4, lanes: 4, blocksPerLane: 5, numberRange: [15, 30, 45, 60, 75] },
                    8: { colors: 5, queueSlots: 4, lanes: 4, blocksPerLane: 5, numberRange: [15, 30, 45, 60, 75] },
                    9: { colors: 5, queueSlots: 4, lanes: 4, blocksPerLane: 6, numberRange: [15, 30, 45, 60, 75] },
                    10: { colors: 5, queueSlots: 4, lanes: 4, blocksPerLane: 6, numberRange: [15, 30, 45, 60, 75, 90] },
                    11: { colors: 5, queueSlots: 4, lanes: 4, blocksPerLane: 6, numberRange: [15, 30, 45, 60, 75, 90] },
                    12: { colors: 5, queueSlots: 4, lanes: 4, blocksPerLane: 7, numberRange: [15, 30, 45, 60, 75, 90] },
                    13: { colors: 5, queueSlots: 4, lanes: 4, blocksPerLane: 8, numberRange: [15, 30, 45, 60, 75, 90, 120] },
                    14: { colors: 5, queueSlots: 4, lanes: 4, blocksPerLane: 9, numberRange: [15, 30, 45, 60, 75, 90, 120] },
                    15: { colors: 5, queueSlots: 4, lanes: 4, blocksPerLane: 10, numberRange: [15, 30, 45, 60, 75, 90, 120] }
                };
                this.colors = [];
                this.targetNumbers = [];
                this.stackNumbers = [];
                this.targetLanes = [];
                this.stacks = [];
                this.attackQueue = [];
                this.gameRunning = false;
                this._queueScanTimer = null;
                this._pendingUpdate = false;
                this._particleCount = 0;
                this._maxParticles = 30;
                this.handleBlockTouch = this.handleBlockTouch.bind(this);
                this.colorParticleMap = {
                    red: { color: '#fca5a5', dark: '#f87171' },
                    blue: { color: '#93c5fd', dark: '#60a5fa' },
                    green: { color: '#86efac', dark: '#4ade80' },
                    yellow: { color: '#fde047', dark: '#facc15' },
                    purple: { color: '#c4b5fd', dark: '#a78bfa' }
                };
            }
            showMessage(text, type = '') {
                const messageEl = document.getElementById('message');
                messageEl.textContent = text;
                messageEl.className = `message ${type}`;
                setTimeout(() => {
                    if (messageEl.textContent === text) {
                        messageEl.textContent = '';
                        messageEl.className = 'message';
                    }
                }, 3000);
            }
            clearAllParticles() {
                const particles = document.querySelectorAll('.shooting-particle');
                particles.forEach(p => {
                    if (p.parentNode) {
                        p.parentNode.removeChild(p);
                        this._particleCount = Math.max(0, this._particleCount - 1);
                    }
                });
                this._particleCount = 0;
            }
            initGame() {
                this.stopQueueScanLoop();
                this.stage = 1;
                this.score = 0;
                this.clearedStages.clear();
                this._pendingUpdate = false;
                this.clearAllParticles();
                this.initStage();
                this.updateDisplay();
                this.updateStageProgress();
                this.showMessage('🎮 새 게임을 시작합니다!', 'success');
            }
            initStage() {
                const config = this.stageConfig[this.stage];
                this.colors = this.fullColorPool.slice(0, config.colors);
                this.targetNumbers = config.numberRange;
                this.stackNumbers = config.numberRange;
                this.targetLanes = Array(config.lanes).fill().map(() => []);
                this.stacks = Array(config.lanes).fill().map(() => []);
                this.attackQueue = Array(config.queueSlots).fill(null);
                this.clearAllParticles();
                this.generateStageBlocks(config);
                this.updateQueueUI();
                this.updateStageProgress();
            }
            generateStageBlocks(config) {
                const colorTotals = {};
                this.colors.forEach(color => colorTotals[color] = 0);
                for (let lane = 0; lane < config.lanes; lane++) {
                    this.targetLanes[lane] = [];
                    for (let i = 0; i < config.blocksPerLane; i++) {
                        const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                        const number = this.targetNumbers[Math.floor(Math.random() * this.targetNumbers.length)];
                        this.targetLanes[lane].push({ color, number, id: Date.now() + lane * 1000 + i });
                        colorTotals[color] += number;
                    }
                }
                const stackBlocks = [];
                this.colors.forEach(color => {
                    let remaining = colorTotals[color];
                    while (remaining > 0) {
                        const number = Math.min(
                            this.stackNumbers[Math.floor(Math.random() * this.stackNumbers.length)],
                            remaining
                        );
                        stackBlocks.push({ color, number, id: Date.now() + Math.random() });
                        remaining -= number;
                    }
                });
                stackBlocks.sort(() => Math.random() - 0.5);
                const blocksPerStack = Math.ceil(stackBlocks.length / config.lanes);
                for (let s = 0; s < config.lanes; s++) {
                    this.stacks[s] = stackBlocks.slice(s * blocksPerStack, (s + 1) * blocksPerStack);
                }
            }
            startGame() {
                this.gameRunning = true;
                this.clearAllParticles();
                this.showMessage(`🚀 스테이지 ${this.stage} 시작!`, 'success');
                this.updateDisplay();
                this.updateStageProgress();
                this.startQueueScanLoop();
            }
            resetGame() {
                this.stopQueueScanLoop();
                this.gameRunning = false;
                this._pendingUpdate = false;
                this.clearAllParticles();
                this.initGame();
                this.startGame();
            }
            getAvailableQueueSlot() {
                return this.attackQueue.findIndex(slot => slot === null || slot.number <= 0);
            }
            selectBlock(stackIndex) {
                if (!this.gameRunning) {
                    this.showMessage('❌ 게임이 시작되지 않았습니다!', 'error');
                    return false;
                }
                if (stackIndex < 0 || stackIndex >= this.stacks.length) {
                    this.showMessage(`❌ 잘못된 스택: ${stackIndex + 1}`, 'error');
                    return false;
                }
                const slotIndex = this.getAvailableQueueSlot();
                if (slotIndex === -1) {
                    this.showMessage('⚠️ 대기열이 가득 찼습니다!', 'warning');
                    return false;
                }
                const stack = this.stacks[stackIndex];
                if (!stack || stack.length === 0) {
                    this.showMessage(`❌ 스택 ${stackIndex + 1}이 비었습니다!`, 'error');
                    return false;
                }
                const topBlock = stack[0];
                const queueBlock = {
                    ...topBlock,
                    stackIndex,
                    id: Date.now() + Math.random(),
                    isFiring: false,
                    queuePosition: slotIndex
                };
                this.attackQueue[slotIndex] = queueBlock;
                this.stacks[stackIndex].shift();
                this.showMessage(`✅ ${topBlock.color} 블록 (${topBlock.number}) 추가`, 'success');
                console.log(`블록(${topBlock.color}, ${topBlock.number}) 추가`);
                this.updateQueue();
                this.scheduleUpdate(() => {
                    this.scanAndFireOnce();
                    this.checkStageClear();
                });
                if ('vibrate' in navigator) {
                    navigator.vibrate(50);
                }
                return true;
            }
            startQueueScanLoop() {
                if (this._queueScanTimer) {
                    clearInterval(this._queueScanTimer);
                    this._queueScanTimer = null;
                }
                this._queueScanTimer = setInterval(() => {
                    if (!this.gameRunning) return;
                    this.scanAndFireOnce();
                }, 120);
            }
            stopQueueScanLoop() {
                if (this._queueScanTimer) {
                    clearInterval(this._queueScanTimer);
                    this._queueScanTimer = null;
                }
                this.clearAllParticles();
            }
            scanAndFireOnce() {
                if (!this.gameRunning) return;
                const firingColors = new Set();
                for (let qIndex = 0; qIndex < this.attackQueue.length; qIndex++) {
                    const q = this.attackQueue[qIndex];
                    if (q && q.isFiring) {
                        firingColors.add(q.color);
                    }
                }
                for (let qIndex = 0; qIndex < this.attackQueue.length; qIndex++) {
                    const q = this.attackQueue[qIndex];
                    if (!q || q.isFiring || q.number <= 0) {
                        continue;
                    }
                    if (firingColors.has(q.color)) continue;
                    let foundLane = -1;
                    for (let laneIndex = 0; laneIndex < this.targetLanes.length; laneIndex++) {
                        const lane = this.targetLanes[laneIndex];
                        if (lane.length > 0 && lane[0].color === q.color) {
                            foundLane = laneIndex;
                            break;
                        }
                    }
                    if (foundLane !== -1) {
                        this.attackQueue[qIndex].isFiring = true;
                        firingColors.add(q.color);
                        this.fireFromQueueIndex(qIndex, foundLane);
                    }
                }
                this.checkQueueStuck();
            }
            fireFromQueueIndex(queueIndex, laneIndex) {
                const queued = this.attackQueue[queueIndex];
                if (!queued || queued.number <= 0) {
                    this.attackQueue[queueIndex] = null;
                    this.scheduleUpdate();
                    return;
                }
                const lane = this.targetLanes[laneIndex];
                if (!lane || lane.length === 0) {
                    this.attackQueue[queueIndex].isFiring = false;
                    this.scheduleUpdate();
                    return;
                }
                const shotInterval = 1000 / 40;
                let shotsFired = 0;
                let lastShotTime = performance.now();
                const fireLoop = (now) => {
    if (!this.gameRunning) {
        if (this.attackQueue[queueIndex]) this.attackQueue[queueIndex].isFiring = false;
        this.scheduleUpdate();
        return;
    }
    const lane = this.targetLanes[laneIndex];
    if (!lane || lane.length === 0 || lane[0].color !== queued.color) {
        if (this.attackQueue[queueIndex]) this.attackQueue[queueIndex].isFiring = false;
        this.scheduleUpdate();
        return;
    }
    const currentBottom = lane[0];
    if (!currentBottom) {
        if (this.attackQueue[queueIndex]) this.attackQueue[queueIndex].isFiring = false;
        this.scheduleUpdate();
        return;
    }
    
    // 한 프레임에 여러 발을 쏠 수 있도록 while 루프 추가
    while (now - lastShotTime >= shotInterval && queued.number > 0 && currentBottom.number > 0) {
        if (this._particleCount < this._maxParticles) {
            this.createSingleParticle(queueIndex, laneIndex, queued.color);
            this._particleCount++;
        }
        currentBottom.number -= 1;
        queued.number -= 1;
        shotsFired++;
        this.score += 1;
        lastShotTime += shotInterval; // now가 아닌 shotInterval을 더해서 정확한 간격 유지
        
        if (currentBottom.number <= 0) {
            this.targetLanes[laneIndex].shift();
            if (lane.length > 0 && lane[0].color === queued.color) {
                // 다음 블록으로 전환
                break;
            } else {
                // 더 이상 매칭되는 블록이 없음
                break;
            }
        }
    }
    
    // 진동은 프레임당 한 번만
    if (shotsFired > 0 && 'vibrate' in navigator) {
        navigator.vibrate(30);
    }
    
    this.updateDisplay();
    this.updateTargetLanes();
    this.updateQueue();
    
    if (queued.number > 0 && lane.length > 0 && lane[0].color === queued.color) {
        requestAnimationFrame(fireLoop);
    } else {
        this.showDamageText(laneIndex, shotsFired);
        this.showMessage(`🎯 매칭 성공! +${shotsFired}점`, 'success');
        console.log(`매칭 성공! +${shotsFired}점`);
        if (queued.number > 0) {
            console.log(`잔여값 ${queued.number} 남음`);
        } else {
            this.attackQueue[queueIndex] = null;
        }
        if (this.attackQueue[queueIndex]) this.attackQueue[queueIndex].isFiring = false;
        this.updateTargetLanes();
        this.scheduleUpdate(() => {
            this.checkStageClear();
        });
    }
};
                requestAnimationFrame(fireLoop);
            }
            createSingleParticle(queueIndex, laneIndex, color) {
                const queueArea = document.getElementById('queueArea');
                const targetLanes = document.getElementById('targetLanes');
                const slotEl = queueArea.children[queueIndex];
                if (!slotEl) {
                    this._particleCount = Math.max(0, this._particleCount - 1);
                    return;
                }
                const slotRect = slotEl.getBoundingClientRect();
                const startX = slotRect.left + slotRect.width / 2 + window.scrollX;
                const startY = slotRect.top + slotRect.height / 2 + window.scrollY;
                const laneEl = targetLanes.children[laneIndex];
                if (!laneEl) {
                    this._particleCount = Math.max(0, this._particleCount - 1);
                    return;
                }
                const bottomBlock = laneEl.children[0];
                if (!bottomBlock) {
                    this._particleCount = Math.max(0, this._particleCount - 1);
                    return;
                }
                const targetRect = bottomBlock.getBoundingClientRect();
                const targetX = targetRect.left + targetRect.width / 2 + window.scrollX;
                const targetY = targetRect.top + targetRect.height / 2 + window.scrollY;
                const p = document.createElement('div');
                p.className = 'shooting-particle';
                const particleColors = this.colorParticleMap[color];
                if (particleColors) {
                    p.style.setProperty('--particle-color', particleColors.color);
                    p.style.setProperty('--particle-color-dark', particleColors.dark);
                } else {
                    p.style.setProperty('--particle-color', '#ffffff');
                    p.style.setProperty('--particle-color-dark', '#cccccc');
                }
                p.style.left = startX + 'px';
                p.style.top = startY + 'px';
                p.style.opacity = '1';
                document.body.appendChild(p);
                const duration = 250;
                const start = performance.now();
                function easeOutCubic(t) {
                    return 1 - Math.pow(1 - t, 3);
                }
                const frame = (now) => {
                    const t = Math.min(1, (now - start) / duration);
                    const eased = easeOutCubic(t);
                    const curX = startX + (targetX - startX) * eased + (Math.random() - 0.5) * 2;
                    const curY = startY + (targetY - startY) * eased + (Math.random() - 0.5) * 2;
                    p.style.left = curX + 'px';
                    p.style.top = curY + 'px';
                    p.style.opacity = String(1 - eased * 0.3);
                    const scale = 1 - 0.4 * eased;
                    p.style.transform = `translate(-50%,-50%) scale(${scale})`;
                    if (t < 1) {
                        requestAnimationFrame(frame);
                    } else {
                        if (p.parentNode) {
                            p.parentNode.removeChild(p);
                            this._particleCount = Math.max(0, this._particleCount - 1);
                        }
                    }
                };
                requestAnimationFrame(frame.bind(this));
                setTimeout(() => {
                    if (p.parentNode) {
                        p.parentNode.removeChild(p);
                        this._particleCount = Math.max(0, this._particleCount - 1);
                    }
                }, duration + 100);
            }
            showDamageText(laneIndex, damage) {
                const targetLanesEl = document.getElementById('targetLanes');
                const laneEl = targetLanesEl.children[laneIndex];
                if (!laneEl) return;
                const bottomBlock = laneEl.children[0];
                if (!bottomBlock) return;
                const rect = bottomBlock.getBoundingClientRect();
                const tx = rect.left + rect.width / 2;
                const ty = rect.top + rect.height / 2;
                const d = document.createElement('div');
                d.className = 'damage-text';
                d.textContent = `-${damage}`;
                d.style.left = tx + 'px';
                d.style.top = ty + 'px';
                document.body.appendChild(d);
                setTimeout(() => {
                    if (d.parentNode) d.parentNode.removeChild(d);
                }, 1000);
            }
            checkStageClear() {
                const allCleared = this.targetLanes.every(lane => lane.length === 0);
                if (allCleared) {
                    this.clearedStages.add(this.stage);
                    this.gameRunning = false;
                    this.stopQueueScanLoop();
                    this.clearAllParticles();
                    console.log(`Stage ${this.stage} cleared, targetLanes: ${JSON.stringify(this.targetLanes)}`);
                    if (this.stage < 15) {
                        this.showStageClearModal(`스테이지 ${this.stage} 클리어! 점수: ${this.score}`);
                    } else {
                        this.saveScoreAndFinish();
                    }
                }
            }
            async saveScoreAndAdvance() {
                try {
                    const scoreData = {
                        name: playerName || '익명',
                        score: Number(this.score),
                        timestamp: Date.now()
                    };
                    await push(ref(db, 'scores/game1'), scoreData);
                    this.advanceStage();
                } catch (error) {
                    console.error('Stage score save error:', error);
                    this.showMessage(`⚠️ 점수 저장 실패: ${error.message}`, 'error');
                    this.advanceStage();
                }
            }
            async saveScoreAndFinish() {
                try {
                    console.log('Saving final score:', this.score, 'for player:', playerName);
                    const scoreData = {
                        name: playerName || '익명',
                        score: Number(this.score),
                        timestamp: Date.now()
                    };
                    console.log('Score data to save:', scoreData);
                    await push(ref(db, 'scores/game1'), scoreData);
                    console.log('Score saved successfully');
                    const rankings = await this.fetchRankings();
                    this.showGameOverModal(`🎉 모든 스테이지 완료!\n최종 점수: ${this.score}점\n\n랭킹에 등록되었습니다!`, rankings);
                } catch (error) {
                    console.error('Score save error:', error);
                    console.error('Error details:', error.message, error.code);
                    this.showGameOverModal(`🎉 모든 스테이지 완료!\n최종 점수: ${this.score}점\n\n⚠️ 랭킹 등록 실패: ${error.message}`, []);
                }
            }
            showStageClearModal(message) {
                console.log('Showing stage clear modal');
                const root = document.getElementById('modalRoot');
                root.innerHTML = '';
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop';
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `<h2>🎉 스테이지 클리어!</h2><p>${message}</p>`;
                const actions = document.createElement('div');
                actions.className = 'modal-actions';
                const retry = document.createElement('button');
                retry.className = 'btn btn-retry';
                retry.textContent = '🏠 홈으로';
                retry.addEventListener('click', () => {
                    console.log('Home button clicked');
                    root.innerHTML = '';
                    window.location.href = 'index.html';
                });
                const next = document.createElement('button');
                next.className = 'btn btn-next';
                next.textContent = '▶️ 다음 스테이지';
                next.addEventListener('click', () => {
                    console.log('Next stage button clicked');
                    root.innerHTML = '';
                    this.saveScoreAndAdvance();
                });
                actions.appendChild(retry);
                actions.appendChild(next);
                modal.appendChild(actions);
                backdrop.appendChild(modal);
                root.appendChild(backdrop);
                backdrop.classList.add('show');
                if ('vibrate' in navigator) {
                    navigator.vibrate([200, 100, 200]);
                }
            }
            showGameOverModal(message, rankings) {
                const root = document.getElementById('modalRoot');
                root.innerHTML = '';
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop';
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `<h2>🎮 게임 오버</h2><p style="white-space: pre-line;">${message}</p>`;
                const rankingDiv = document.createElement('div');
                rankingDiv.style.margin = '20px 0';
                rankingDiv.style.textAlign = 'left';
                rankingDiv.style.fontSize = '14px';
                rankingDiv.style.color = '#0284c7';
                rankingDiv.innerHTML = '<h3 style="margin: 0 0 10px 0; font-size: 16px;">🏆 랭킹</h3>';
                if (rankings.length === 0) {
                    rankingDiv.innerHTML += '<p>랭킹 데이터 없음</p>';
                } else {
                    rankings.forEach((entry, index) => {
                        rankingDiv.innerHTML += `<p><span style="font-weight: 600;">${index + 1}위</span> ${entry.name || '익명'} - ${entry.score}점</p>`;
                    });
                }
                modal.appendChild(rankingDiv);
                const actions = document.createElement('div');
                actions.className = 'modal-actions';
                                const retry = document.createElement('button');
                retry.className = 'btn btn-retry';
                retry.textContent = '🔄 재도전';
                retry.style.width = '100%';
                retry.style.minHeight = '44px';
                retry.onclick = () => {
                    root.innerHTML = '';
                    this.resetGame();
                };
                const continueBtn = document.createElement('button');
                continueBtn.className = 'btn btn-continue';
                continueBtn.textContent = '📺 광고 보고 이어하기';
                continueBtn.style.width = '100%';
                continueBtn.style.minHeight = '44px';
                continueBtn.onclick = () => {
                    root.innerHTML = '';
                    this.showAdModal();
                };
                const home = document.createElement('button');
                home.className = 'btn btn-home';
                home.textContent = '🏠 홈으로';
                home.style.width = '100%';
                home.style.minHeight = '44px';
                home.onclick = () => {
                    root.innerHTML = '';
                    window.location.href = 'index.html';
                };
                actions.appendChild(retry);
                actions.appendChild(continueBtn);
                actions.appendChild(home);
                modal.appendChild(actions);
                backdrop.appendChild(modal);
                root.appendChild(backdrop);
                backdrop.classList.add('show');
            }
            showAdModal() {
                const root = document.getElementById('modalRoot');
                root.innerHTML = '';
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop';
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `
                    <h2>📺 광고 문의</h2>
                    <p>이 영역 광고 문의 받습니다! 😄<br>지금은 광고가 없으니 그냥 재미로 즐겨주세요!</p>
                `;
                const actions = document.createElement('div');
                actions.className = 'modal-actions';
                const close = document.createElement('button');
                close.className = 'btn btn-close';
                close.textContent = '❌ 닫기';
                close.onclick = () => {
                    root.innerHTML = '';
                    this.resetGame();
                };
                actions.appendChild(close);
                modal.appendChild(actions);
                backdrop.appendChild(modal);
                root.appendChild(backdrop);
                backdrop.classList.add('show');
                if ('vibrate' in navigator) {
                    navigator.vibrate([50]);
                }
            }
            advanceStage() {
                this.stopQueueScanLoop();
                this.clearAllParticles();
                this.stage++;
                console.log(`Advancing to stage ${this.stage}`);
                this.initStage();
                this.updateQueueUI();
                this.updateStacksAndQueue();
                this.updateTargetLanes();
                this.updateStageProgress();
                this.updateDisplay();
                this.gameRunning = true;
                this.startQueueScanLoop();
                this.showMessage(`🚀 스테이지 ${this.stage} 시작!`, 'success');
            }
            checkQueueStuck() {
                if (this.getAvailableQueueSlot() !== -1) {
                    this.scheduleUpdate();
                    return;
                }
                for (let q of this.attackQueue) {
                    if (!q || q.number <= 0) continue;
                    for (let lane of this.targetLanes) {
                        if (lane.length > 0 && lane[0].color === q.color) {
                            this.scheduleUpdate();
                            return;
                        }
                    }
                }
                this.gameRunning = false;
                this.stopQueueScanLoop();
                this.showMessage('❌ 대기열이 가득 차 매칭 불가!', 'error');
                this.saveScoreAndGameOver();
            }
            async saveScoreAndGameOver() {
                try {
                    console.log('Saving game over score:', this.score, 'for player:', playerName);
                    const scoreData = {
                        name: playerName || '익명',
                        score: Number(this.score),
                        timestamp: Date.now()
                    };
                    console.log('Score data to save:', scoreData);
                    await push(ref(db, 'scores/game1'), scoreData);
                    console.log('Score saved successfully');
                    const rankings = await this.fetchRankings();
                    this.showGameOverModal(`게임 오버!\n최종 점수: ${this.score}점\n\n랭킹에 등록되었습니다!`, rankings);
                } catch (error) {
                    console.error('Score save error:', error);
                    console.error('Error details:', error.message, error.code);
                    this.showGameOverModal(`게임 오버!\n최종 점수: ${this.score}점\n\n⚠️ 랭킹 등록 실패: ${error.message}`, []);
                }
            }
            async fetchRankings() {
                try {
                    const scoresRef = ref(db, 'scores/game1');
                    const topScoresQuery = query(scoresRef, orderByChild('score'), limitToLast(3));
                    const snapshot = await get(topScoresQuery);
                    const rankings = [];
                    snapshot.forEach((child) => {
                        rankings.unshift(child.val());
                    });
                    return rankings;
                } catch (error) {
                    console.error('Error fetching rankings:', error);
                    return [];
                }
            }
            updateStageProgress() {
                const stageProgress = document.getElementById('stageProgress');
                stageProgress.innerHTML = '';
                for (let i = 1; i <= 15; i++) {
                    const indicator = document.createElement('div');
                    indicator.className = `stage-indicator ${
                        i === this.stage ? 'current' : this.clearedStages.has(i) ? 'cleared' : ''
                    }`;
                    indicator.dataset.stage = i;
                    indicator.textContent = i;
                    stageProgress.appendChild(indicator);
                }
            }
            updateDisplay() {
                document.getElementById('stage').textContent = this.stage;
                document.getElementById('score').textContent = this.score;
                document.getElementById('colorCount').textContent = this.stageConfig[this.stage].colors;
                this.updateTargetLanes();
                this.updateStageProgress();
                this.scheduleUpdate();
            }
            updateTargetLanes() {
                const targetContainer = document.getElementById('targetLanes');
                const fragment = document.createDocumentFragment();
                this.targetLanes.forEach((lane, laneIndex) => {
                    const laneEl = document.createElement('div');
                    laneEl.className = 'target-lane';
                    lane.forEach((block, idx) => {
                        const blockEl = document.createElement('div');
                        blockEl.className = `target-block ${block.color}`;
                        blockEl.innerHTML = `<div class="block-number">${block.number}</div>`;
                        if (idx === 0) {
                            blockEl.classList.add('attackable');
                        }
                        laneEl.appendChild(blockEl);
                    });
                    fragment.appendChild(laneEl);
                });
                targetContainer.innerHTML = '';
                targetContainer.appendChild(fragment);
            }
            updateQueueUI() {
                const queueArea = document.getElementById('queueArea');
                queueArea.innerHTML = '';
                const config = this.stageConfig[this.stage];
                for (let i = 0; i < config.queueSlots; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'queue-slot';
                    slot.id = `queue${i}`;
                    slot.textContent = 'Empty';
                    queueArea.appendChild(slot);
                }
                this.updateQueue();
            }
            scheduleUpdate(callback = null) {
                if (this._pendingUpdate) return;
                this._pendingUpdate = true;
                requestAnimationFrame(() => {
                    this.updateStacksAndQueue();
                    this._pendingUpdate = false;
                    if (callback) callback();
                    this.checkStageClear();
                });
            }
            updateStacksAndQueue() {
                const stacksContainer = document.getElementById('stacksContainer');
                stacksContainer.innerHTML = '';
                this.stacks.forEach((stack, stackIndex) => {
                    const stackEl = document.createElement('div');
                    stackEl.className = 'stack';
                    for (let blockIndex = 0; blockIndex < stack.length; blockIndex++) {
                        const block = stack[blockIndex];
                        const blockEl = document.createElement('div');
                        blockEl.className = `stack-block ${block.color}`;
                        blockEl.innerHTML = `<div class="block-number">${block.number}</div>`;
                        blockEl.dataset.stackIndex = stackIndex;
                        if (blockIndex === 0 && this.gameRunning && this.getAvailableQueueSlot() !== -1) {
                            blockEl.classList.add('top-block');
                            blockEl.addEventListener('pointerdown', (e) => {
                                e.preventDefault();
                                this.handleBlockTouch(stackIndex);
                            }, { passive: false, once: true });
                        } else {
                            blockEl.style.cursor = 'not-allowed';
                        }
                        stackEl.appendChild(blockEl);
                    }
                    stacksContainer.appendChild(stackEl);
                });
                this.updateQueue();
            }
            updateQueue() {
                const queueArea = document.getElementById('queueArea');
                for (let i = 0; i < this.attackQueue.length; i++) {
                    const slot = queueArea.children[i];
                    if (!slot) continue;
                    slot.innerHTML = '';
                    slot.className = 'queue-slot';
                    if (this.attackQueue[i] && this.attackQueue[i].number > 0) {
                        const block = this.attackQueue[i];
                        slot.className = `queue-block ${block.color} ${!block.isFiring ? 'added' : ''}`;
                        slot.innerHTML = `<div class="block-number">${block.number}</div>`;
                    } else {
                        slot.innerHTML = 'Empty';
                        if (this.attackQueue[i]) {
                            this.attackQueue[i] = null;
                        }
                    }
                }
            }
            handleBlockTouch(stackIndex) {
                this.selectBlock(stackIndex);
            }
        }
        let game;
        function startIntroGame() {
            playerName = localStorage.getItem('playerName') || 'Guest';
            document.getElementById('intro').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex';
            if (!game) {
                game = new ColorShooterGame();
                game.initGame();
            }
            game.startGame();
        }
        function resetGame() {
            if (game) game.resetGame();
        }
        function goHome() {
  if (parent.resetIframe) {
    parent.resetIframe(); // 부모의 iframe 초기화 호출
  }
  parent.document.querySelector('h1').style.display = 'block';
  parent.document.getElementById('carousel').style.display = 'block';
  parent.document.getElementById('user-info').style.display = 'flex';
  if (parent.playBGM) {
    parent.playBGM(false); // BGM 유지
  }
  if ('vibrate' in navigator) {
    navigator.vibrate(50);
  }
}
        document.addEventListener('DOMContentLoaded', function() {
            createBackgroundEffects();
            document.getElementById('intro').style.display = 'flex';
            document.getElementById('gameContainer').style.display = 'none';
            const nameDisplay = document.createElement('p');
            nameDisplay.style.color = '#0284c7';
            nameDisplay.style.fontWeight = '700';
            nameDisplay.textContent = `👤 플레이어: ${playerName}`;
            document.getElementById('intro').insertBefore(nameDisplay, document.getElementById('startGameBtn'));
            document.getElementById('startGameBtn').addEventListener('click', startIntroGame);
            document.getElementById('goHomeBtn').addEventListener('click', goHome);
            document.getElementById('resetGameBtn').addEventListener('click', resetGame);
            document.getElementById('goHomeBtn2').addEventListener('click', goHome);
            console.log('Game loaded at', new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' }));
        });
    </script>
</body>
</html>