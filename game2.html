<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.5, user-scalable=yes" />
    <title>탕탕특공대 - 슈팅 게임</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pretendard@1.3.9/dist/web/static/pretendard.min.css">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            padding: 0;
            font-family: 'Pretendard', Arial, sans-serif;
            background: linear-gradient(135deg, #e0f2fe 0%, #ddd6fe 50%, #fce7f3 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease-in-out infinite;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            overflow: hidden;
            position: relative;
        }
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        .sparkle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #93c5fd, transparent);
            border-radius: 50%;
            animation: sparkleAnim var(--duration) ease-in-out infinite;
            opacity: 0;
            box-shadow: 0 0 10px rgba(147, 197, 253, 0.8);
            pointer-events: none;
        }
        @keyframes sparkleAnim {
            0%, 100% { opacity: 0; transform: scale(0.5) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.5) rotate(180deg); }
        }
        #intro {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(14, 165, 233, 0.2);
            max-width: 90vw;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 10;
            position: relative;
            border: 3px solid rgba(147, 197, 253, 0.5);
        }
        #intro h1 {
            margin: 0;
            font-size: 36px;
            color: #0284c7;
            font-weight: 800;
        }
        #intro p {
            margin: 0;
            font-size: 18px;
            color: #64748b;
            line-height: 1.6;
        }
        .game-instructions {
            background: rgba(240, 249, 255, 0.8);
            border-radius: 15px;
            padding: 20px;
            margin: 10px 0;
            text-align: left;
            font-size: 14px;
            color: #0369a1;
            line-height: 1.5;
            border: 2px solid rgba(147, 197, 253, 0.3);
        }
        .game-instructions h3 {
            margin: 0 0 10px 0;
            color: #0284c7;
            font-size: 16px;
        }
        .intro-btn {
            background: linear-gradient(135deg, #38bdf8, #818cf8);
            color: #fff;
            border: none;
            padding: 16px 32px;
            border-radius: 18px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 700;
            transition: all 0.3s ease;
            touch-action: manipulation;
            box-shadow: 0 8px 20px rgba(56, 189, 248, 0.4);
            position: relative;
            overflow: hidden;
        }
        .intro-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        .intro-btn:hover::before {
            left: 100%;
        }
        .intro-btn:active {
            transform: scale(0.95);
        }
        .intro-btn.btn-home {
            background: linear-gradient(135deg, #94a3b8, #64748b);
            box-shadow: 0 8px 20px rgba(100, 116, 139, 0.3);
        }
        .game-container {
            display: none;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 8px;
            box-shadow: 0 20px 60px rgba(14, 165, 233, 0.2);
            width: 100vw;
            max-width: 95vw;
            height: 100vh;
            max-height: 95vh;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            overflow: hidden;
            touch-action: manipulation;
            z-index: 10;
            position: relative;
            border: 3px solid rgba(147, 197, 253, 0.5);
        }
        #gameCanvas {
            display: block;
            background: #000;
            width: 100%;
            max-width: 450px;
            height: auto;
            max-height: 70vh;
            border-radius: 15px;
            border: 2px solid rgba(147, 197, 253, 0.3);
            flex-shrink: 1;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .game-ui {
            background: rgba(240, 249, 255, 0.8);
            border-radius: 15px;
            padding: 10px;
            margin: 8px 0;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            font-size: 12px;
            color: #0284c7;
            font-weight: 700;
            border: 2px solid rgba(147, 197, 253, 0.3);
            width: 100%;
            max-width: 450px;
        }
        .game-ui > div {
            background: rgba(147, 197, 253, 0.15);
            padding: 6px 10px;
            border-radius: 10px;
            text-align: center;
        }
        .game-ui span {
            color: #7c3aed;
            font-size: 14px;
        }
        .game-controls {
            display: flex;
            gap: 10px;
            margin-top: 8px;
            width: 100%;
            max-width: 450px;
        }
        .btn {
            flex: 1;
            color: #fff;
            border: none;
            padding: 10px 16px;
            border-radius: 12px;
            background: linear-gradient(145deg, #38bdf8, #818cf8);
            font-weight: 600;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(56, 189, 248, 0.3);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(56, 189, 248, 0.5);
        }
        .btn:active {
            transform: scale(0.95);
        }
        .btn-home {
            background: linear-gradient(145deg, #94a3b8, #64748b);
            box-shadow: 0 4px 15px rgba(100, 116, 139, 0.3);
        }
        #joystick {
            position: fixed;
            width: 140px;
            height: 140px;
            z-index: 1000;
            touch-action: none;
            pointer-events: none;
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        #joystick.active {
            display: block;
            opacity: 1;
        }
        #joyBase {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: rgba(147, 197, 253, 0.15);
            border: 3px solid rgba(56, 189, 248, 0.6);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.3) inset;
        }
        #joyStick {
            position: absolute;
            width: 68px;
            height: 68px;
            border-radius: 50%;
            left: 36px;
            top: 36px;
            background: rgba(56, 189, 248, 0.7);
            border: 3px solid #38bdf8;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.8);
            touch-action: none;
        }
        #leaderboard {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            width: 200px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(147, 197, 253, 0.5);
            border-radius: 15px;
            padding: 15px;
            font-size: 12px;
            box-shadow: 0 8px 32px rgba(14, 165, 233, 0.15);
        }
        #leaderboard h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #0284c7;
            text-align: center;
        }
        #leaderboard ol {
            margin: 0;
            padding-left: 20px;
            max-height: 200px;
            overflow: auto;
        }
        #leaderboard li {
            line-height: 1.8;
            color: #0369a1;
        }
        #leaderboard .empty {
            color: #94a3b8;
            text-align: center;
            list-style: none;
        }
        .modal-backdrop {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(186, 230, 253, 0.3);
            backdrop-filter: blur(15px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            animation: fadeIn 0.3s ease-out;
        }
        #gameOverModal {
            z-index: 3000; /* 명시적 z-index */
        }
        #statusModal {
            cursor: pointer;
            z-index: 3100; /* gameOverModal보다 높음 */
        }
        #statusModal.show {
            display: flex;
        }

        .modal-backdrop.show {
            display: flex;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(30px);
            padding: 40px 30px;
            border-radius: 25px;
            width: 90vw;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(14, 165, 233, 0.3);
            border: 3px solid rgba(147, 197, 253, 0.5);
            animation: modalBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        @keyframes modalBounce {
            0% {
                transform: scale(0.5) translateY(50px);
                opacity: 0;
            }
            70% {
                transform: scale(1.05) translateY(-10px);
            }
            100% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        .modal h2 {
            margin: 0 0 15px 0;
            font-size: 28px;
            color: #0284c7;
            font-weight: 800;
        }
        .modal p {
            margin: 10px 0;
            font-size: 16px;
            color: #64748b;
            line-height: 1.5;
        }
        .modal input {
            width: 100%;
            padding: 12px 16px;
            margin: 15px 0;
            border: 2px solid rgba(147, 197, 253, 0.5);
            border-radius: 12px;
            font-size: 16px;
            font-family: 'Pretendard', sans-serif;
            background: rgba(240, 249, 255, 0.8);
            color: #0c4a6e;
            outline: none;
            transition: all 0.3s ease;
        }
        .modal input:focus {
            border-color: #38bdf8;
            background: #fff;
            box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.15);
        }
        .button-group {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 20px;
    width: 100%; /* 버튼 가로 길게 */
}
.modal button {
    width: 100%; /* 각 버튼 가로 전체 채우기 */
}
        .modal button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .modal button.primary {
            background: linear-gradient(135deg, #38bdf8, #818cf8);
            color: #fff;
            box-shadow: 0 8px 20px rgba(56, 189, 248, 0.4);
        }
        .modal button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(56, 189, 248, 0.5);
        }
        .modal button.secondary {
            background: rgba(226, 232, 240, 0.8);
            color: #64748b;
            border: 2px solid rgba(148, 163, 184, 0.3);
        }
        .modal button.secondary:hover {
            background: rgba(203, 213, 225, 0.9);
        }
        .ranking-in-modal {
            margin: 20px 0;
            text-align: left;
            font-size: 14px;
            color: #0284c7;
        }
        .ranking-in-modal h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            text-align: center;
        }
        .ranking-in-modal p {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(147, 197, 253, 0.15);
            border-radius: 8px;
            margin: 5px 0;
        }
        #item-counter {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(147, 197, 253, 0.5);
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 700;
            color: #0284c7;
            box-shadow: 0 4px 12px rgba(14, 165, 233, 0.15);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* 추가: 탭 스타일 */
        .tab-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 12px;
            background: rgba(226, 232, 240, 0.8);
            color: #64748b;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .tab-btn.active {
            background: linear-gradient(135deg, #38bdf8, #818cf8);
            color: #fff;
            box-shadow: 0 4px 15px rgba(56, 189, 248, 0.4);
        }
        .tab-btn:hover {
            transform: translateY(-2px);
        }
        .tab-content {
            text-align: left;
            font-size: 14px;
            color: #0284c7;
        }
        #playerHighScores {
            max-height: 150px;
            overflow-y: auto;
            padding: 5px;
        }
        #playerHighScores p {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(147, 197, 253, 0.15);
            border-radius: 8px;
            margin: 5px 0;
            font-size: 12px;
        }
        #playerHighScores p span {
            color: #7c3aed;
            font-weight: 700;
        }
        #playerHighScores .empty {
            text-align: center;
            color: #94a3b8;
        }


        #finalStatus {
            text-align: left;
            font-size: 14px;
            color: #0284c7;
            margin: 20px 0;
        }
        #finalStatus h3 {
            margin: 10px 0 5px 0;
            font-size: 16px;
        }
        #finalStatus .item-count {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            padding: 5px;
            background: rgba(147, 197, 253, 0.15);
            border-radius: 8px;
            margin: 5px 0;
        }
        #finalStatus .item-count span, #finalStatus p span {
            color: #7c3aed;
            font-weight: 700;
        }        
        #item-counter h3 {
            margin: 0 0 5px 0;
            font-size: 16px;
            text-align: center;
        }
        .item-count {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        .item-count span {
            color: #7c3aed;
            font-weight: 700;
        }
        @media (max-width: 768px) {
            #intro {
                padding: 30px 20px;
            }
            #intro h1 {
                font-size: 28px;
            }
            #joystick {
                width: 120px;
                height: 120px;
                bottom: 20px;
                left: 20px;
            }
            #joyStick {
                width: 58px;
                height: 58px;
                left: 31px;
                top: 31px;
            }
            #leaderboard {
                width: 160px;
                top: 10px;
                right: 10px;
                padding: 10px;
            }
            #item-counter {
                top: 10px;
                left: 10px;
                padding: 6px 10px;
                font-size: 12px;
            }
            .item-count {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="intro">
        <h1>🎯 탕탕특공대</h1>
        <p>적을 물리치고 최고 점수에 도전하세요!</p>
        <div class="game-instructions">
            <h3>📖 게임 방법</h3>
            <p>• 조이스틱으로 이동</p>
            <p>• 자동으로 가장 가까운 적 공격</p>
            <p>• 아이템을 수집해 파워업</p>
        </div>
        <button class="intro-btn" id="startGameBtn">🚀 게임 시작</button>
        <button class="intro-btn btn-home" id="goHomeBtn">🏠 홈으로</button>
    </div>

    <div class="game-container" id="gameContainer">
        <div id="item-counter">
            <h3>🧳 아이템</h3>
            <div class="item-count">🔥 연사력 강화: <span id="fireRateCount">0</span></div>
            <div class="item-count">💫 멀티샷: <span id="multiShotCount">0</span></div>
            <div class="item-count">🏃 이동속도: <span id="speedUpCount">0</span></div>
            <div class="item-count">🛡️ 보호막: <span id="shieldCount">0</span></div>
            <div class="item-count">🚀 이알 속도: <span id="bulletSpeedCount">0</span></div>
        </div>
        <canvas id="gameCanvas" width="400" height="736"></canvas>
        <div class="game-ui">
            <div>🎯 점수: <span id="score">0</span></div>
            <div>❤️ 생명: <span id="lives">3</span></div>
            <div>🌊 웨이브: <span id="wave">1</span></div>
            <div>🛡️ 보호막: <span id="shield">0</span></div>
            <div>🔥 연사: <span id="fireRate">1.0</span>x</div>
            <div>💫 멀티: <span id="multiShot">1</span>발</div>
        </div>
        <div class="game-controls">
            <button class="btn" id="resetGameBtn">🔄 재시작</button>
            <button class="btn btn-home" id="goHomeBtn2">🏠 홈으로</button>
        </div>
    </div>

    <div id="joystick">
        <div id="joyBase"></div>
        <div id="joyStick"></div>
    </div>

    <div id="leaderboard" style="display: none;">
        <h3>🏆 랭킹 TOP 10</h3>
        <ol id="lbList">
            <li class="empty">플레이 후 점수를 저장해보세요.</li>
        </ol>
    </div>

    <div id="gameOverModal" class="modal-backdrop">
    <div class="modal">
        <h2>🎮 게임 오버</h2>
        <p>최종 점수: <span id="finalScore" style="color: #7c3aed; font-weight: 800; font-size: 24px;">0</span></p>
        <p style="color: #10b981; font-weight: 700;">랭킹에 등록되었습니다!</p>
        <div class="ranking-in-modal" id="rankingInModal">
            <h3>🏆 랭킹</h3>
        </div>
        <div class="button-group">
            <button class="secondary" id="restartBtn">🔄 재도전</button>
            <button class="secondary" id="goHomeModalBtn">🏠 홈으로</button>
            <button class="primary" id="showStatusBtn">📊 최종 상태</button>
        </div>
    </div>
</div>
    <!-- 추가: 최종 상태 팝업창 -->
    <div id="statusModal" class="modal-backdrop">
        <div class="modal">
            <h2>📊 게임 결과</h2>
            <div class="tab-group">
                <button class="tab-btn active" id="statusTabBtn">최종 상태</button>
                <button class="tab-btn" id="highScoreTabBtn">내 하이스코어</button>
            </div>
            <div id="statusTab" class="tab-content">
                <h3>🧳 수집한 아이템</h3>
                <p class="item-count">🔥 연사력 강화: <span id="finalFireRateCount">0</span></p>
                <p class="item-count">💫 멀티샷: <span id="finalMultiShotCount">0</span></p>
                <p class="item-count">🏃 이동속도: <span id="finalSpeedUpCount">0</span></p>
                <p class="item-count">🛡️ 보호막: <span id="finalShieldCount">0</span></p>
                <p class="item-count">🚀 이알 속도: <span id="finalBulletSpeedCount">0</span></p>
                <h3>🧑‍🚀 캐릭터 상태</h3>
                <p>🏃 이동 속도: <span id="finalSpeed">0</span></p>
                <p>🔥 연사 속도: <span id="finalFireRate">0</span>x</p>
                <p>💫 멀티샷: <span id="finalMultiShot">0</span>발</p>
                <p>🛡️ 보호막: <span id="finalShield">0</span></p>
                <p>🚀 이알 속도: <span id="finalBulletSpeed">0</span>x</p>
                <p>🌊 최종 웨이브: <span id="finalWave">0</span></p>
            </div>
            <div id="highScoreTab" class="tab-content" style="display: none;">
                <h3>🏆 내 하이스코어 (최대 10개)</h3>
                <div id="playerHighScores"></div>
            </div>
            <p style="color: #10b981; font-weight: 700;">터치하여 닫기</p>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
        import { getDatabase, ref, push, query, orderByChild, limitToLast, get } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyC-M1czGNwh3-xMLHgmEdVmfbHZAmQioiQ",
            authDomain: "gukhyeon-ce3ba.firebaseapp.com",
            databaseURL: "https://gukhyeon-ce3ba-default-rtdb.firebaseio.com",
            projectId: "gukhyeon-ce3ba",
            storageBucket: "gukhyeon-ce3ba.firebasestorage.app",
            messagingSenderId: "751956972723",
            appId: "1:751956972723:web:cedb2e5f483529732e8cc6",
            measurementId: "G-JBBLJNDGY1"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        let playerName = localStorage.getItem('playerName') || 'Guest';
        let scoreSaved = false;

        function createBackgroundEffects() {
            for (let i = 0; i < 30; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                sparkle.style.left = `${Math.random() * 100}%`;
                sparkle.style.top = `${Math.random() * 100}%`;
                sparkle.style.setProperty('--duration', `${Math.random() * 3 + 2}s`);
                sparkle.style.animationDelay = `${Math.random() * 3}s`;
                document.body.appendChild(sparkle);
            }
        }

        async function loadHighScores() {
            try {
                const scoresRef = ref(db, 'scores/game2');
                const topScoresQuery = query(scoresRef, orderByChild('score'), limitToLast(10));
                const snapshot = await get(topScoresQuery);
                const rankings = [];
                snapshot.forEach((child) => {
                    rankings.unshift(child.val());
                });
                renderLeaderboard(rankings);
                return rankings;
            } catch (error) {
                console.error('Error loading rankings:', error);
                return [];
            }
        }

        function renderLeaderboard(rankings) {
            const list = document.getElementById('lbList');
            if (!list) return;
            list.innerHTML = '';
            if (rankings.length === 0) {
                const li = document.createElement('li');
                li.className = 'empty';
                li.textContent = '플레이 후 점수를 저장해보세요.';
                list.appendChild(li);
                return;
            }
            rankings.forEach((row, idx) => {
                const li = document.createElement('li');
                li.textContent = `${row.name} — ${row.score}`;
                list.appendChild(li);
            });
        }

        // 추가: 플레이어의 하이스코어 조회
        async function loadPlayerHighScores() {
            try {
                const scoresRef = ref(db, 'scores/game2');
                const topScoresQuery = query(scoresRef, orderByChild('score'), limitToLast(1000)); // 전체 점수 조회 (최대 1000개)
                const snapshot = await get(topScoresQuery);
                const allScores = [];
                const playerScores = [];
                
                // 전체 점수 수집
                snapshot.forEach((child) => {
                    const scoreData = child.val();
                    allScores.push(scoreData);
                    if (scoreData.name === playerName) {
                        playerScores.push(scoreData);
                    }
                });
                
                // 점수 내림차순 정렬
                allScores.sort((a, b) => b.score - a.score);
                playerScores.sort((a, b) => b.score - a.score);
                
                // 플레이어 점수에 전체 순위 추가
                const rankedPlayerScores = playerScores.slice(0, 10).map(playerScore => {
                    const globalRank = allScores.findIndex(score => 
                        score.score === playerScore.score && 
                        score.name === playerScore.name && 
                        score.timestamp === playerScore.timestamp
                    ) + 1;
                    return { ...playerScore, globalRank };
                });
                
                return rankedPlayerScores;
            } catch (error) {
                console.error('Error loading player high scores:', error);
                return [];
            }
        }

        // 추가: 하이스코어 렌더링
        function renderPlayerHighScores(scores) {
            const highScoreDiv = document.getElementById('playerHighScores');
            highScoreDiv.innerHTML = '';
            if (scores.length === 0) {
                const p = document.createElement('p');
                p.className = 'empty';
                p.textContent = '기록된 점수가 없습니다.';
                highScoreDiv.appendChild(p);
                return;
            }
            scores.forEach((score, index) => {
                const p = document.createElement('p');
                p.innerHTML = `<span>${index + 1}위</span> <span>${score.score}점 (전체 ${score.globalRank}위, ${new Date(score.timestamp).toLocaleString('ko-KR')})</span>`;
                highScoreDiv.appendChild(p);
            });
        }

        async function saveHighScore(name, score) {
            try {
                const scoreData = {
                    name: (name || 'Player').trim().slice(0, 12) || 'Player',
                    score: +score || 0,
                    timestamp: Date.now()
                };
                await push(ref(db, 'scores/game2'), scoreData);
                localStorage.setItem('playerName', scoreData.name);
                return await loadHighScores();
            } catch (error) {
                console.error('Score save error:', error);
                return [];
            }
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        ctx.imageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;

        let gameState = {
            score: 0,
            lives: 3,
            wave: 1,
            gameOver: false,
            paused: false,
            keys: {},
            enemyCount: 0,
            maxEnemies: 15,
            time: 0,
            shotTimer: 0,
            baseFireRate: 0.22,
            itemCounts: {
                FIRE_RATE: 0,
                MULTI_SHOT: 0,
                SPEED_UP: 0,
                SHIELD: 0,
                BULLET_SPEED: 0
            }
        };

        const player = {
            x: 200, y: 368, width: 30, height: 30,
            speed: 220,
            color: '#00ff88',
            lastDir: {x: 0, y: -1},
            invuln: 0,
            fireRate: 1.0,
            bulletSpeed: 1.0,
            multiShot: 1,
            shield: 0,
            powerUpTimer: 0,
            image: null
        };

        let bullets = [];
        let enemies = [];
        let particles = [];
        let items = [];

        const images = {
            player: new Image(),
            enemy: new Image(),
            bullet: new Image(),
            background: new Image()
        };

        let imagesLoaded = {
            player: false,
            enemy: false,
            bullet: false,
            background: false
        };

        images.player.onload = () => { imagesLoaded.player = true; };
        images.player.onerror = () => { imagesLoaded.player = false; };
        images.player.src = 'assets/player.png';

        images.enemy.onload = () => { imagesLoaded.enemy = true; };
        images.enemy.onerror = () => { imagesLoaded.enemy = false; };
        images.enemy.src = 'assets/enemy.png';

        images.bullet.onload = () => { imagesLoaded.bullet = true; };
        images.bullet.onerror = () => { imagesLoaded.bullet = false; };
        images.bullet.src = 'assets/bullet.png';

        images.background.onload = () => { imagesLoaded.background = true; };
        images.background.onerror = () => { imagesLoaded.background = false; };
        images.background.src = 'assets/background.png';

        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
        function vecNorm(x, y) { const d = Math.hypot(x, y) || 1; return {x: x/d, y: y/d}; }

        document.addEventListener('keydown', (e) => {
            if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
            gameState.keys[e.code] = true;
            if (e.code === 'KeyR') restartGame();
            if (e.code === 'KeyP') gameState.paused = !gameState.paused;
        });
        document.addEventListener('keyup', (e) => gameState.keys[e.code] = false);

        const joyBase = document.getElementById('joyBase');
        const joyStick = document.getElementById('joyStick');
        const joyWrap = document.getElementById('joystick');

        const joystick = {
            active: false,
            id: null,
            startX: 0,
            startY: 0,
            dx: 0,
            dy: 0,
            amp: 0
        };

        const DEADZONE = 0.15;
        const JOYSTICK_RADIUS = 70;

        function showJoystick(x, y) {
            joyWrap.style.left = `${x - JOYSTICK_RADIUS}px`;
            joyWrap.style.top = `${y - JOYSTICK_RADIUS}px`;
            joyWrap.classList.add('active');
            joystick.startX = x;
            joystick.startY = y;
            centerStick();
        }

        function hideJoystick() {
            joyWrap.classList.remove('active');
            joystick.active = false;
            joystick.dx = joystick.dy = joystick.amp = 0;
            centerStick();
        }

        function centerStick() {
            joyStick.style.left = '36px';
            joyStick.style.top = '36px';
        }

        function updateJoystickFromTouch(touchX, touchY) {
            const dx = touchX - joystick.startX;
            const dy = touchY - joystick.startY;
            const dist = Math.hypot(dx, dy);
            const amp = Math.min(dist / JOYSTICK_RADIUS, 1);
            const nx = dist ? dx / dist : 0;
            const ny = dist ? dy / dist : 0;
            const clampedX = nx * amp * JOYSTICK_RADIUS;
            const clampedY = ny * amp * JOYSTICK_RADIUS;
            joyStick.style.left = `${JOYSTICK_RADIUS - joyStick.offsetWidth / 2 + clampedX}px`;
            joyStick.style.top = `${JOYSTICK_RADIUS - joyStick.offsetHeight / 2 + clampedY}px`;
            joystick.dx = nx;
            joystick.dy = ny;
            joystick.amp = amp;
            joystick.active = amp > DEADZONE;
        }

        const gameContainer = document.getElementById('gameContainer');
        const gameControls = document.querySelector('.game-controls');

        gameContainer.addEventListener('touchstart', (e) => {
            if (gameState.gameOver || gameState.paused) return;
            const touch = e.changedTouches[0];
            const controlsRect = gameControls.getBoundingClientRect();
            if (touch.clientY >= controlsRect.top) return;
            e.preventDefault();
            joystick.id = touch.identifier;
            showJoystick(touch.clientX, touch.clientY);
            updateJoystickFromTouch(touch.clientX, touch.clientY);
        }, { passive: false });

        gameContainer.addEventListener('touchmove', (e) => {
            if (gameState.gameOver || gameState.paused) return;
            for (const touch of e.changedTouches) {
                if (touch.identifier === joystick.id) {
                    e.preventDefault();
                    updateJoystickFromTouch(touch.clientX, touch.clientY);
                }
            }
        }, { passive: false });

        function endTouch(e) {
            for (const touch of e.changedTouches) {
                if (touch.identifier === joystick.id) {
                    joystick.id = null;
                    hideJoystick();
                }
            }
        }

        gameContainer.addEventListener('touchend', endTouch, { passive: false });
        gameContainer.addEventListener('touchcancel', endTouch, { passive: false });

        function movePlayer(dt) {
            if (joystick.active) {
                const speed = player.speed * joystick.amp;
                player.x += joystick.dx * speed * dt;
                player.y += joystick.dy * speed * dt;
                if (joystick.amp > DEADZONE + 0.02) {
                    player.lastDir = vecNorm(joystick.dx, joystick.dy);
                }
            } else {
                let dx = 0, dy = 0;
                if (gameState.keys['ArrowLeft']) dx -= 1;
                if (gameState.keys['ArrowRight']) dx += 1;
                if (gameState.keys['ArrowUp']) dy -= 1;
                if (gameState.keys['ArrowDown']) dy += 1;
                if (dx || dy) {
                    const v = vecNorm(dx, dy);
                    player.x += v.x * player.speed * dt;
                    player.y += v.y * player.speed * dt;
                    player.lastDir = v;
                }
            }
            player.x = clamp(player.x, 0, canvas.width - player.width);
            player.y = clamp(player.y, 0, canvas.height - player.height);
        }

        function fire(dir) {
            if (gameState.gameOver) return;
            const speed = 700 * player.bulletSpeed;
            for (let i = 0; i < player.multiShot; i++) {
                const angle = i === 0 ? 0 : (i % 2 === 1 ? 1 : -1) * Math.ceil(i / 2) * 0.3;
                const finalDir = {
                    x: dir.x * Math.cos(angle) - dir.y * Math.sin(angle),
                    y: dir.x * Math.sin(angle) + dir.y * Math.cos(angle)
                };
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y + player.height / 2 - 2,
                    width: 4, height: 4,
                    vx: finalDir.x * speed, vy: finalDir.y * speed,
                    color: '#ffff00'
                });
            }
        }

        function autoFire(dt) {
            gameState.shotTimer -= dt;
            const curRate = Math.max(0.10, gameState.baseFireRate - (gameState.wave - 1) * 0.01) / player.fireRate;
            if (gameState.shotTimer <= 0) {
                let target = null, bestD = Infinity;
                for (const e of enemies) {
                    const cx = e.x + e.width / 2, cy = e.y + e.height / 2;
                    const dx = cx - (player.x + player.width / 2);
                    const dy = cy - (player.y + player.height / 2);
                    const d = dx * dx + dy * dy;
                    if (d < bestD) { bestD = d; target = {dx, dy}; }
                }
                const dir = target ? vecNorm(target.dx, target.dy) : player.lastDir;
                fire(dir);
                gameState.shotTimer = curRate;
            }
        }

        function spawnEnemy(dt) {
            if (gameState.enemyCount >= gameState.maxEnemies) return;
            const spawnPerSecond = 1.2 + Math.min(20, gameState.wave) * 0.35; // 수정: 웨이브 20 이상에서 고정
            const p = 1 - Math.exp(-spawnPerSecond * dt);
            if (Math.random() < p) {
                const hpMultiplier = Math.floor(gameState.wave / 10);
                const enemyHp = 1 + hpMultiplier;
                const enemy = { 
                    width: 25, 
                    height: 25, 
                    speed: Math.min(250, 60 + gameState.wave * 10), // 적군 속도 조절 
                    color: '#ff4444', 
                    x: 0, 
                    y: 0, 
                    vx: 0, 
                    vy: 0,
                    hp: enemyHp,
                    maxHp: enemyHp
                };
                const side = Math.floor(Math.random() * 4);
                if (side === 0) { enemy.x = Math.random() * canvas.width; enemy.y = -enemy.height; }
                if (side === 1) { enemy.x = Math.random() * canvas.width; enemy.y = canvas.height; }
                if (side === 2) { enemy.x = -enemy.width; enemy.y = Math.random() * canvas.height; }
                if (side === 3) { enemy.x = canvas.width; enemy.y = Math.random() * canvas.height; }
                enemies.push(enemy);
                gameState.enemyCount++;
            }
        }

        const itemTypes = {
            FIRE_RATE: { color: '#ff6666', symbol: 'F', name: '연사력 강화' },
            MULTI_SHOT: { color: '#6666ff', symbol: 'M', name: '멀티샷' },
            SPEED_UP: { color: '#66ff66', symbol: 'S', name: '이동속도 증가' },
            SHIELD: { color: '#ffff66', symbol: 'H', name: '보호막' },
            BULLET_SPEED: { color: '#ff66ff', symbol: 'B', name: '이알 속도' }
        };

        function spawnItem(x, y) {
            if (Math.random() < 0.3) {
                const types = Object.keys(itemTypes);
                const type = types[Math.floor(Math.random() * types.length)];
                items.push({ x: x - 10, y: y - 10, width: 20, height: 20, type, life: 10, bob: Math.random() * Math.PI * 2 });
            }
        }

        function collectItem(item) {
            const type = item.type;
            createExplosion(item.x + 10, item.y + 10, itemTypes[type].color, 8);
            gameState.itemCounts[type]++; // Increment the counter for the specific item type
            switch (type) {
                case 'FIRE_RATE': player.fireRate = Math.min(3.0, player.fireRate + 0.3); player.powerUpTimer = 15; break;
                case 'MULTI_SHOT': player.multiShot = Math.min(5, player.multiShot + 1); player.powerUpTimer = 15; break;
                case 'SPEED_UP': 
                    player.speed = Math.min(500, player.speed + 30); 
                    player.powerUpTimer = 10; 
                    createExplosion(player.x + player.width / 2, player.y + player.height / 2, '#66ff66', 12); // 속도 증가 이펙트
                    break;      
                case 'SHIELD': player.shield = Math.min(3, player.shield + 1); break;
                case 'BULLET_SPEED': player.bulletSpeed = Math.min(2.0, player.bulletSpeed + 0.2); player.powerUpTimer = 15; break;
            }
            updateUI();
        }

        function createExplosion(x, y, color = '#ffff00', count = 12) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count, sp = 80 + Math.random() * 120;
                particles.push({ x, y, vx: Math.cos(angle) * sp, vy: Math.sin(angle) * sp, life: 0.4 + Math.random() * 0.4, maxLife: 0.8, color, size: 2 + Math.random() * 2 });
            }
        }

        function rectHit(a, b) {
            return a.x < b.x + b.width && a.x + a.width > b.x &&
                a.y < b.y + b.height && a.y + a.height > b.y;
        }

        function update(dt) {
            if (gameState.gameOver || gameState.paused) return;
            gameState.time += dt;
            if (player.invuln > 0) player.invuln = Math.max(0, player.invuln - dt);
            if (player.powerUpTimer > 0) {
                player.powerUpTimer = Math.max(0, player.powerUpTimer - dt);
                if (player.powerUpTimer <= 0) {
                    player.fireRate = 1.0; player.bulletSpeed = 1.0; player.multiShot = 1; player.speed = 220;
                }
            }
            movePlayer(dt);
            autoFire(dt);
            spawnEnemy(dt);
            bullets = bullets.filter(b => {
                b.x += b.vx * dt; b.y += b.vy * dt;
                return b.x > -10 && b.x < canvas.width + 10 && b.y > -10 && b.y < canvas.height + 10;
            });
            for (const e of enemies) {
                const dx = (player.x + player.width / 2) - (e.x + e.width / 2);
                const dy = (player.y + player.height / 2) - (e.y + e.height / 2);
                const v = vecNorm(dx, dy);
                e.vx = v.x * e.speed; e.vy = v.y * e.speed;
                e.x += e.vx * dt; e.y += e.vy * dt;
            }
            enemies = enemies.filter(e => {
                const inBounds = e.x > -60 && e.x < canvas.width + 60 && e.y > -60 && e.y < canvas.height + 60;
                if (!inBounds) gameState.enemyCount--;
                return inBounds;
            });
            items = items.filter(item => { item.life -= dt; item.bob += dt * 3; return item.life > 0; });
            particles = particles.filter(p => {
                p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
                p.vx *= (1 - 1.5 * dt); p.vy *= (1 - 1.5 * dt);
                return p.life > 0;
            });
            outer:
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (rectHit(bullets[i], enemies[j])) {
                        const e = enemies[j];
                        e.hp = (e.hp || 1) - 1;
                        bullets.splice(i, 1);
                        if (e.hp <= 0) {
                            const ex = e.x + e.width / 2;
                            const ey = e.y + e.height / 2;
                            createExplosion(ex, ey, '#ff8844', 10);
                            spawnItem(ex, ey);
                            enemies.splice(j, 1);
                            gameState.enemyCount--;
                            gameState.score += 50;
                            if (gameState.score > 0 && gameState.score % 500 === 0) { 
                                gameState.wave++; 
                                gameState.maxEnemies += 3; 
                            }
                        } else {
                            const ex = e.x + e.width / 2;
                            const ey = e.y + e.height / 2;
                            createExplosion(ex, ey, '#ffaa44', 3);
                        }
                        continue outer;
                    }
                }
            }
            for (let i = items.length - 1; i >= 0; i--) {
                if (rectHit(player, items[i])) { collectItem(items[i]); items.splice(i, 1); }
            }
            if (player.invuln <= 0) {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (rectHit(enemies[i], player)) {
                        const ex = enemies[i].x + enemies[i].width / 2;
                        const ey = enemies[i].y + enemies[i].height / 2;
                        if (player.shield > 0) {
                            player.shield--;
                            createExplosion(ex, ey, '#ffff66', 15);
                            enemies.splice(i, 1);
                            gameState.enemyCount--;
                            player.invuln = 0.5;
                        } else {
                            createExplosion(ex, ey, '#ff4444', 12);
                            createExplosion(player.x + player.width / 2, player.y + player.height / 2, '#00ff88', 16);
                            enemies.splice(i, 1);
                            gameState.enemyCount--;
                            gameState.lives--;
                            player.invuln = 1.2;
                            const dkx = (player.x + player.width / 2) - ex;
                            const dky = (player.y + player.height / 2) - ey;
                            const len = Math.hypot(dkx, dky) || 1;
                            player.x = clamp(player.x + (dkx / len) * 40, 0, canvas.width - player.width);
                            player.y = clamp(player.y + (dky / len) * 40, 0, canvas.height - player.height);
                            if (gameState.lives <= 0) endGame();
                        }
                        break;
                    }
                }
            }
            updateUI();
        }

        function draw() {
            if (imagesLoaded.background) {
                ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = 'rgba(0,17,34,0.35)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            const blink = player.invuln > 0 ? Math.floor(gameState.time * 10) % 2 === 0 : true;
            if (blink) {
                if (imagesLoaded.player) {
                    const img = images.player;
                    const aspectRatio = img.width / img.height;
                    let drawWidth = player.width;
                    let drawHeight = player.height;
                    if (aspectRatio > 1) {
                        drawHeight = drawWidth / aspectRatio;
                    } else {
                        drawWidth = drawHeight * aspectRatio;
                    }
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                    ctx.drawImage(img, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                    ctx.restore();
                } else {
                    ctx.fillStyle = player.color;
                    ctx.fillRect(player.x + 10, player.y, 10, 30);
                    ctx.fillRect(player.x, player.y + 10, 30, 10);
                    ctx.shadowColor = player.color; ctx.shadowBlur = 10;
                    ctx.fillRect(player.x + 12, player.y + 12, 6, 6);
                    ctx.shadowBlur = 0;
                }
                if (player.shield > 0) {
                    ctx.strokeStyle = '#ffff66';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(player.x + player.width / 2, player.y + player.height / 2, 25, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            for (const b of bullets) {
                if (imagesLoaded.bullet) {
                    const img = images.bullet;
                    const aspectRatio = img.width / img.height;
                    let drawWidth = b.width * 3;
                    let drawHeight = b.height * 3;
                    if (aspectRatio > 1) {
                        drawHeight = drawWidth / aspectRatio;
                    } else {
                        drawWidth = drawHeight * aspectRatio;
                    }
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.translate(b.x + b.width / 2, b.y + b.height / 2);
                    const angle = Math.atan2(b.vy, b.vx);
                    ctx.rotate(angle);
                    ctx.drawImage(img, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                    ctx.restore();
                } else {
                    ctx.fillStyle = b.color;
                    ctx.shadowColor = b.color; ctx.shadowBlur = 8;
                    ctx.fillRect(b.x, b.y, b.width, b.height);
                    ctx.shadowBlur = 0;
                }
            }
            for (const e of enemies) {
                if (imagesLoaded.enemy) {
                    const img = images.enemy;
                    const aspectRatio = img.width / img.height;
                    let drawWidth = e.width;
                    let drawHeight = e.height;
                    if (aspectRatio > 1) {
                        drawHeight = drawWidth / aspectRatio;
                    } else {
                        drawWidth = drawHeight * aspectRatio;
                    }
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.translate(e.x + e.width / 2, e.y + e.height / 2);
                    if (e.hp < e.maxHp) {
                        const flashIntensity = 0.5;
                        ctx.globalAlpha = 0.7;
                        ctx.filter = `hue-rotate(${Math.sin(gameState.time * 20) * 30}deg) brightness(1.3)`;
                    }
                    ctx.drawImage(img, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                    ctx.filter = 'none';
                    ctx.globalAlpha = 1;
                    ctx.restore();
                    if (e.hp < e.maxHp) {
                        const barWidth = e.width;
                        const barHeight = 3;
                        const barX = e.x;
                        const barY = e.y - 8;
                        const hpRatio = e.hp / e.maxHp;
                        ctx.fillStyle = '#ff4444';
                        ctx.fillRect(barX, barY, barWidth, barHeight);
                        ctx.fillStyle = '#4ade80';
                        ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
                    }
                } else {
                    const cx = e.x + e.width / 2, cy = e.y + e.height / 2;
                    ctx.fillStyle = e.color;
                    ctx.beginPath();
                    ctx.moveTo(cx, e.y);
                    ctx.lineTo(e.x + e.width, cy);
                    ctx.lineTo(cx, e.y + e.height);
                    ctx.lineTo(e.x, cy);
                    ctx.closePath();
                    ctx.shadowColor = e.color; ctx.shadowBlur = 5;
                    ctx.fill(); ctx.shadowBlur = 0;
                    if (e.hp && e.hp < e.maxHp) {
                        const barWidth = e.width;
                        const barHeight = 3;
                        const barX = e.x;
                        const barY = e.y - 8;
                        const hpRatio = e.hp / e.maxHp;
                        ctx.fillStyle = '#ff4444';
                        ctx.fillRect(barX, barY, barWidth, barHeight);
                        ctx.fillStyle = '#4ade80';
                        ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
                    }
                }
            }
            for (const item of items) {
                const bobOffset = Math.sin(item.bob) * 3;
                const alpha = item.life < 2 ? Math.sin(item.life * 5) * 0.5 + 0.5 : 1;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = itemTypes[item.type].color;
                ctx.shadowColor = itemTypes[item.type].color; ctx.shadowBlur = 10;
                ctx.fillRect(item.x, item.y + bobOffset, item.width, item.height);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#000000';
                ctx.font = '12px bold monospace';
                ctx.textAlign = 'center';
                ctx.fillText(itemTypes[item.type].symbol, item.x + item.width / 2, item.y + item.height / 2 + 4 + bobOffset);
                ctx.globalAlpha = 1;
            }
            for (const p of particles) {
                const a = Math.max(0, p.life / p.maxLife);
                ctx.globalAlpha = a;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1;
            }
        }
        
        // 추가: 최종 상태 모달 표시
        function showStatusModal() {
            const modal = document.getElementById('statusModal');
            modal.classList.add('show');
            switchTab('status'); // 초기 탭을 상태로 설정
            updateUI();
            if ('vibrate' in navigator) {
                navigator.vibrate([50]);
            }
        }

        // 추가: 최종 상태 모달 숨김
        function hideStatusModal() {
            const modal = document.getElementById('statusModal');
            modal.classList.remove('show');
            if ('vibrate' in navigator) {
                navigator.vibrate(50);
            }
        }

        // 추가: 탭 전환
        function switchTab(event, tab) {
            event.stopPropagation(); // 상위 이벤트 전파 차단
            const statusTab = document.getElementById('statusTab');
            const highScoreTab = document.getElementById('highScoreTab');
            const statusBtn = document.getElementById('statusTabBtn');
            const highScoreBtn = document.getElementById('highScoreTabBtn');

            if (tab === 'status') {
                statusTab.style.display = 'block';
                highScoreTab.style.display = 'none';
                statusBtn.classList.add('active');
                highScoreBtn.classList.remove('active');
                updateUI();
            } else {
                statusTab.style.display = 'none';
                highScoreTab.style.display = 'block';
                statusBtn.classList.remove('active');
                highScoreBtn.classList.add('active');
                loadPlayerHighScores().then(renderPlayerHighScores);
            }
        }


        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('shield').textContent = player.shield;
            document.getElementById('fireRate').textContent = player.fireRate.toFixed(1);
            document.getElementById('multiShot').textContent = player.multiShot;
            document.getElementById('fireRateCount').textContent = gameState.itemCounts.FIRE_RATE;
            document.getElementById('multiShotCount').textContent = gameState.itemCounts.MULTI_SHOT;
            document.getElementById('speedUpCount').textContent = gameState.itemCounts.SPEED_UP;
            document.getElementById('shieldCount').textContent = gameState.itemCounts.SHIELD;
            document.getElementById('bulletSpeedCount').textContent = gameState.itemCounts.BULLET_SPEED;
            // 최종 상태 탭 업데이트
            if (document.getElementById('statusTab').style.display !== 'none') {
                document.getElementById('finalFireRateCount').textContent = gameState.itemCounts.FIRE_RATE;
                document.getElementById('finalMultiShotCount').textContent = gameState.itemCounts.MULTI_SHOT;
                document.getElementById('finalSpeedUpCount').textContent = gameState.itemCounts.SPEED_UP;
                document.getElementById('finalShieldCount').textContent = gameState.itemCounts.SHIELD;
                document.getElementById('finalBulletSpeedCount').textContent = gameState.itemCounts.BULLET_SPEED;
                document.getElementById('finalSpeed').textContent = player.speed.toFixed(0);
                document.getElementById('finalFireRate').textContent = player.fireRate.toFixed(1);
                document.getElementById('finalMultiShot').textContent = player.multiShot;
                document.getElementById('finalShield').textContent = player.shield;
                document.getElementById('finalBulletSpeed').textContent = player.bulletSpeed.toFixed(1);
                document.getElementById('finalWave').textContent = gameState.wave;
            }
        }

        function showAdModal() {
            const modal = document.getElementById('gameOverModal');
            modal.classList.remove('show');
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop';
            const modalContent = document.createElement('div');
            modalContent.className = 'modal';
            modalContent.innerHTML = `
                <h2>📺 광고 문의</h2>
                <p>이 영역 광고 문의 받습니다! 😄<br>지금은 광고가 없으니 그냥 재미로 즐겨주세요!</p>
            `;
            const actions = document.createElement('div');
            actions.className = 'button-group';
            const close = document.createElement('button');
            close.className = 'primary';
            close.textContent = '❌ 닫기';
            close.onclick = () => {
                backdrop.remove();
                restartGame();
            };
            actions.appendChild(close);
            modalContent.appendChild(actions);
            backdrop.appendChild(modalContent);
            document.body.appendChild(backdrop);
            if ('vibrate' in navigator) {
                navigator.vibrate([50]);
            }
        }

        async function endGame() {
    gameState.gameOver = true;
    document.getElementById('finalScore').textContent = gameState.score;
    try {
        console.log('Saving final score:', gameState.score, 'for player:', playerName);
        const scoreData = {
            name: playerName || '익명',
            score: Number(gameState.score),
            timestamp: Date.now()
        };
        await push(ref(db, 'scores/game2'), scoreData);
        console.log('Score saved successfully');
        const rankings = await loadHighScores();
        const rankingDiv = document.getElementById('rankingInModal');
        const medals = ['🥇', '🥈', '🥉'];
        rankingDiv.innerHTML = '<h3>🏆 랭킹</h3>';
        if (rankings.length === 0) {
            rankingDiv.innerHTML += '<p style="text-align: center;">랭킹 데이터 없음</p>';
        } else {
            rankings.slice(0, 5).forEach((entry, index) => {
                const medal = index < 3 ? medals[index] : `${index + 1}위`;
                rankingDiv.innerHTML += `<p><span style="font-weight: 600;">${medal}</span> <span>${entry.name || '익명'} - ${entry.score}점</span></p>`;
            });
        }
        document.getElementById('gameOverModal').classList.add('show');
        if ('vibrate' in navigator) {
            navigator.vibrate([200, 100, 200]);
        }
    } catch (error) {
        console.error('Score save error:', error);
        const rankingDiv = document.getElementById('rankingInModal');
        rankingDiv.innerHTML = '<h3>🏆 랭킹</h3><p style="text-align: center;">⚠️ 랭킹 등록 실패: ' + error.message + '</p>';
        document.getElementById('gameOverModal').classList.add('show');
        if ('vibrate' in navigator) {
            navigator.vibrate([200, 100, 200]);
        }
    }
    // 세로 UI 통일을 위한 스타일 추가 (game1.html 스타일 참고)
    const modal = document.querySelector('.modal');
    if (modal) {
        modal.style.display = 'flex';
        modal.style.flexDirection = 'column';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.gap = '15px';
    }
    // 모달 표시 후 버튼 이벤트 재등록 (동적 문제 방지)
    document.getElementById('restartBtn').addEventListener('click', restartGame);
    document.getElementById('goHomeModalBtn').addEventListener('click', goHome);
    document.getElementById('showStatusBtn').addEventListener('click', showStatusModal);
    // backdrop 클릭으로 모달 닫기 추가 (빈 공간 클릭 시 닫기)
    document.getElementById('gameOverModal').addEventListener('click', (e) => {
        if (!e.target.closest('.modal')) {
            document.getElementById('gameOverModal').classList.remove('show');
        }
    });
}

        window.restartGame = function() {
            gameState = { 
                score: 0, 
                lives: 3, 
                wave: 1, 
                gameOver: false, 
                paused: false, 
                keys: {}, 
                enemyCount: 0, 
                maxEnemies: 15, 
                time: 0, 
                shotTimer: 0, 
                baseFireRate: 0.22,
                itemCounts: {
                    FIRE_RATE: 0,
                    MULTI_SHOT: 0,
                    SPEED_UP: 0,
                    SHIELD: 0,
                    BULLET_SPEED: 0
                }
            };
            player.x = 200; player.y = 368; player.lastDir = {x: 0, y: -1}; player.invuln = 0;
            player.fireRate = 1.0; player.bulletSpeed = 1.0; player.multiShot = 1; player.shield = 0; player.powerUpTimer = 0; player.speed = 220;
            bullets = []; enemies = []; particles = []; items = [];
            document.getElementById('gameOverModal').classList.remove('show');
            document.getElementById('statusModal').classList.remove('show'); // 추가
            updateUI();
        }

        let last = performance.now();
        function loop(now) {
            const dt = Math.min(0.033, (now - last) / 1000);
            last = now;
            update(dt);
            draw();
            requestAnimationFrame(loop);
        }

        function startGame() {
            document.getElementById('intro').style.display = 'none';
            const gameContainer = document.getElementById('gameContainer');
            gameContainer.style.display = 'flex';
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = 400;
            canvas.height = 736;
            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;
            ctx.msImageSmoothingEnabled = false;
            gameState.itemCounts = {
                FIRE_RATE: 0,
                MULTI_SHOT: 0,
                SPEED_UP: 0,
                SHIELD: 0,
                BULLET_SPEED: 0
            };
            loadHighScores();
            updateUI();
            requestAnimationFrame(loop);
        }

        function goHome(event) {
    if (event) event.stopPropagation(); // 이벤트 전파 차단
    try {
        if (window.parent && window.parent !== window) {
            // iframe 내부: 부모에게 goHome 메시지 전송
            window.parent.postMessage('goHome', '*');
        } else {
            // iframe 외 환경: 직접 처리
            document.getElementById('gameOverModal').classList.remove('show');
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('intro').style.display = 'flex';
        }
        if ('vibrate' in navigator) {
            navigator.vibrate(50);
        }
    } catch (error) {
        console.error('Error in goHome:', error);
    }
}

        document.getElementById('startGameBtn').addEventListener('click', startGame);
        document.getElementById('goHomeBtn').addEventListener('click', goHome);
        document.getElementById('resetGameBtn').addEventListener('click', restartGame);
        document.getElementById('goHomeBtn2').addEventListener('click', goHome);

        document.getElementById('continueAdBtn').addEventListener('click', () => {
            showAdModal();
        });

        document.addEventListener('DOMContentLoaded', () => {
            createBackgroundEffects();
            playerName = localStorage.getItem('playerName') || 'Guest';
            const nameDisplay = document.createElement('p');
            nameDisplay.style.color = '#0284c7';
            nameDisplay.style.fontWeight = '700';
            nameDisplay.textContent = `👤 플레이어: ${playerName}`;
            document.getElementById('intro').insertBefore(nameDisplay, document.getElementById('startGameBtn'));
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('goHomeBtn').addEventListener('click', goHome); // 추가
            document.getElementById('resetGameBtn').addEventListener('click', restartGame);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            document.getElementById('goHomeModalBtn').addEventListener('click', goHome);
            document.getElementById('goHomeBtn2').addEventListener('click', goHome); // 추가
            document.getElementById('continueAdBtn').addEventListener('click', showAdModal);
            document.getElementById('showStatusBtn').addEventListener('click', showStatusModal);
            document.getElementById('statusModal').addEventListener('click', (e) => {
                if (e.target.closest('.tab-group, .tab-content')) return;
                hideStatusModal();
            });
            document.getElementById('statusModal').addEventListener('touchstart', (e) => {
                if (e.target.closest('.tab-group, .tab-content')) return;
                e.preventDefault();
                hideStatusModal();
            }, { passive: false });
            document.getElementById('statusTabBtn').addEventListener('click', (e) => switchTab(e, 'status'));
            document.getElementById('highScoreTabBtn').addEventListener('click', (e) => switchTab(e, 'highScore'));
            document.getElementById('statusTabBtn').addEventListener('touchstart', (e) => {
                e.stopPropagation();
                switchTab(e, 'status');
            }, { passive: false });
            document.getElementById('highScoreTabBtn').addEventListener('touchstart', (e) => {
                e.stopPropagation();
                switchTab(e, 'highScore');
            }, { passive: false });
            document.getElementById('gameOverModal').addEventListener('click', (e) => {
                if (e.target.closest('.modal, .button-group, button')) return; // 버튼/모달 콘텐츠 클릭 시 무시
            });
        });

    </script>
</body>
</html>