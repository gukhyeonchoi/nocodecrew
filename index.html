<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Memory Card Game</title>
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #74ebd5 0%, #ACB6E5 100%);
      min-height: 100vh;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: start;
      padding-top: 20px;
      color: #333;
      position: relative; /* For full-screen effects */
      overflow: hidden;
    }

    #game-board {
      display: grid;
      grid-template-columns: repeat(4, 120px);
      grid-gap: 15px;
      justify-content: center;
      margin: 30px auto;
      perspective: 1000px;
      position: relative;
    }

    .card {
      width: 120px;
      height: 160px;
      position: relative;
      cursor: pointer;
      transform-style: preserve-3d;
      transition: transform 0.4s;
    }

    .card.flipped {
      transform: rotateY(180deg);
    }

    .card .front, .card .back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
    }

    .card .back {
      background: #4a4a4a;
    }

    .card .front {
      background: white;
      transform: rotateY(180deg);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .card.matched .front {
      border: 3px solid limegreen;
      animation: glow 0.8s infinite alternate;
    }

    .card.wrong {
      animation: shake 0.3s;
    }

    @keyframes glow {
      from { box-shadow: 0 0 10px limegreen; }
      to   { box-shadow: 0 0 25px limegreen; }
    }

    @keyframes shake {
      0% { transform: rotateY(180deg) translateX(0); }
      25% { transform: rotateY(180deg) translateX(-5px); }
      50% { transform: rotateY(180deg) translateX(5px); }
      75% { transform: rotateY(180deg) translateX(-5px); }
      100% { transform: rotateY(180deg) translateX(0); }
    }

    #hearts {
      font-size: 28px;
      margin: 10px;
      transition: transform 0.3s;
    }

    #hearts.gain {
      transform: scale(1.3);
      color: crimson;
    }

    #hearts.lose {
      animation: heart-bounce 0.5s;
    }

    @keyframes heart-bounce {
      0% { transform: scale(1); color: crimson; }
      50% { transform: scale(0.7); color: darkred; }
      100% { transform: scale(1); color: crimson; }
    }

    #message {
      font-size: 32px;
      font-weight: bold;
      margin-top: 10px;
      opacity: 0;
      transition: opacity 0.5s, transform 0.5s;
      z-index: 10;
    }

    #message.show {
      opacity: 1;
      transform: scale(1.1);
    }

    #stage-indicator {
      font-size: 24px;
      margin: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 5px;
    }

    .stage-dot {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      color: #666;
      transition: background 0.3s, color 0.3s;
    }

    .stage-dot.active {
      background: #4caf50;
      color: white;
    }

    .particle {
      position: absolute;
      border-radius: 50%;
      opacity: 0.9;
      pointer-events: none;
      animation: particle-burst 0.6s ease-out forwards;
    }

    @keyframes particle-burst {
      0% {
        transform: scale(0) translate(0, 0);
        opacity: 1;
      }
      100% {
        transform: scale(1) translate(var(--dx), var(--dy));
        opacity: 0;
      }
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: var(--color);
      opacity: 0.8;
      pointer-events: none;
      animation: confetti-fall 2s ease-out forwards;
    }

    @keyframes confetti-fall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    .victory-particle {
      position: absolute;
      border-radius: 50%;
      opacity: 0.9;
      pointer-events: none;
      animation: victory-burst 1s ease-out forwards;
    }

    @keyframes victory-burst {
      0% {
        transform: scale(0) translate(0, 0);
        opacity: 1;
      }
      100% {
        transform: scale(2) translate(var(--dx), var(--dy));
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <h1>Memory Card Game</h1>
  <div id="stage-indicator"></div>
  <div id="hearts"></div>
  <div id="game-board"></div>
  <div id="message"></div>

  <script>
    // Configuration object for easy balance adjustments
    const CONFIG = {
      MAX_STAGES: 5,
      HEARTS_PER_STAGE: [10, 8, 5, 4, 3],
      CARD_FLIP_DURATION: 400,
      WRONG_CARD_RESET_DELAY: 400,
      SHAKE_ANIMATION_DURATION: 300,
      GLOW_ANIMATION_DURATION: 800,
      MESSAGE_DISPLAY_DURATION: 1500,
      STAGE_TRANSITION_DELAY: 2000,
      HEART_GAIN_ANIMATION: 300,
      HEART_LOSE_ANIMATION: 500,
      PARTICLE_COUNT: 30, // Increased for more vibrant effect
      PARTICLE_DISTANCE: { MIN: 20, MAX: 100 }, // Wider spread
      CONFETTI_COUNT: 50, // For stage clear
      VICTORY_PARTICLE_COUNT: 100, // For final victory
      VICTORY_PARTICLE_DISTANCE: { MIN: 50, MAX: 200 } // For final victory
    };

    const board = document.getElementById("game-board");
    const heartsDiv = document.getElementById("hearts");
    const messageDiv = document.getElementById("message");
    const stageIndicator = document.getElementById("stage-indicator");

    let stage = 1;
    let hearts = 0;
    let firstCard = null;
    let lockBoard = false;
    let cards = [];

    // Sound effects
    const flipSound = new Audio('https://freesound.org/data/previews/191/191588_2436547-lq.mp3');
    const matchSound = new Audio('https://freesound.org/data/previews/387/387179_7252659-lq.mp3');
    const mismatchSound = new Audio('https://freesound.org/data/previews/342/342749_5760947-lq.mp3');
    const stageClearSound = new Audio('https://freesound.org/data/previews/269/269026_4486188-lq.mp3');
    const gameOverSound = new Audio('https://freesound.org/data/previews/531/531539_11435364-lq.mp3');

    function startStage() {
      hearts = CONFIG.HEARTS_PER_STAGE[stage - 1];
      updateHearts();
      updateStageIndicator();
      showMessage(`Stage ${stage}`);
      board.innerHTML = "";
      cards = generateCards();
      shuffle(cards);

      cards.forEach(img => {
        const card = document.createElement("div");
        card.classList.add("card");

        const front = document.createElement("div");
        front.classList.add("front");
        front.textContent = img;

        const back = document.createElement("div");
        back.classList.add("back");

        card.appendChild(front);
        card.appendChild(back);

        card.dataset.img = img;
        card.addEventListener("click", flipCard);
        board.appendChild(card);
      });
    }

    function updateHearts(change = 0) {
      hearts += change;
      heartsDiv.textContent = "â¤ï¸".repeat(hearts);

      if (change > 0) {
        heartsDiv.classList.add("gain");
        setTimeout(() => heartsDiv.classList.remove("gain"), CONFIG.HEART_GAIN_ANIMATION);
      } else if (change < 0) {
        heartsDiv.classList.add("lose");
        setTimeout(() => heartsDiv.classList.remove("lose"), CONFIG.HEART_LOSE_ANIMATION);
      }
    }

    function showMessage(text) {
      messageDiv.textContent = text;
      messageDiv.classList.add("show");
      setTimeout(() => {
        messageDiv.classList.remove("show");
      }, CONFIG.MESSAGE_DISPLAY_DURATION);
    }

    function updateStageIndicator() {
      stageIndicator.innerHTML = '';
      for (let i = 1; i <= CONFIG.MAX_STAGES; i++) {
        if (i > 1) {
          const connector = document.createTextNode('-');
          stageIndicator.appendChild(connector);
        }
        const dot = document.createElement('div');
        dot.classList.add('stage-dot');
        dot.textContent = i;
        if (i === stage) dot.classList.add('active');
        stageIndicator.appendChild(dot);
      }
    }

    function generateCards() {
      const base = ["ðŸŽ","ðŸŒ","ðŸ‡","ðŸ“","ðŸŠ","ðŸ‰","ðŸ","ðŸ¥"];
      const selected = base.slice(0, 8);
      return [...selected, ...selected];
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function flipCard() {
      if (lockBoard || this.classList.contains("flipped")) return;

      this.classList.add("flipped");
      flipSound.play();

      if (!firstCard) {
        firstCard = this;
      } else {
        checkMatch(this);
      }
    }

    function createMatchParticles(x, y) {
      const colors = ['yellow', 'orange', 'red', 'limegreen', 'cyan', 'magenta'];
      for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        const particle = document.createElement('div');
        particle.classList.add('particle');
        const size = Math.random() * 10 + 5; // Random size between 5-15px
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        const angle = Math.random() * 2 * Math.PI;
        const distance = Math.random() * (CONFIG.PARTICLE_DISTANCE.MAX - CONFIG.PARTICLE_DISTANCE.MIN) + CONFIG.PARTICLE_DISTANCE.MIN;
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;
        particle.style.setProperty('--dx', `${dx}px`);
        particle.style.setProperty('--dy', `${dy}px`);
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        board.appendChild(particle);
        setTimeout(() => particle.remove(), 600);
      }
    }

    function createConfetti() {
      const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'pink'];
      for (let i = 0; i < CONFIG.CONFETTI_COUNT; i++) {
        const confetti = document.createElement('div');
        confetti.classList.add('confetti');
        confetti.style.width = `${Math.random() * 10 + 5}px`;
        confetti.style.height = `${Math.random() * 10 + 5}px`;
        confetti.style.left = `${Math.random() * 100}vw`;
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
        document.body.appendChild(confetti);
        setTimeout(() => confetti.remove(), 2000);
      }
    }

    function createVictoryParticles() {
      const colors = ['gold', 'silver', 'red', 'blue', 'green', 'purple', 'cyan', 'magenta'];
      for (let i = 0; i < CONFIG.VICTORY_PARTICLE_COUNT; i++) {
        const particle = document.createElement('div');
        particle.classList.add('victory-particle');
        const size = Math.random() * 15 + 10; // Larger particles
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        const angle = Math.random() * 2 * Math.PI;
        const distance = Math.random() * (CONFIG.VICTORY_PARTICLE_DISTANCE.MAX - CONFIG.VICTORY_PARTICLE_DISTANCE.MIN) + CONFIG.VICTORY_PARTICLE_DISTANCE.MIN;
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;
        particle.style.setProperty('--dx', `${dx}px`);
        particle.style.setProperty('--dy', `${dy}px`);
        particle.style.left = `${window.innerWidth / 2}px`;
        particle.style.top = `${window.innerHeight / 2}px`;
        document.body.appendChild(particle);
        setTimeout(() => particle.remove(), 1000);
      }
    }

    function checkMatch(secondCard) {
      lockBoard = true;

      if (firstCard.dataset.img === secondCard.dataset.img) {
        firstCard.classList.add("matched");
        secondCard.classList.add("matched");
        matchSound.play();
        updateHearts(+1);

        const rect1 = firstCard.getBoundingClientRect();
        const rect2 = secondCard.getBoundingClientRect();
        const boardRect = board.getBoundingClientRect();
        const centerX = (rect1.left + rect2.left + rect1.width) / 2 - boardRect.left;
        const centerY = (rect1.top + rect2.top + rect1.height) / 2 - boardRect.top;
        createMatchParticles(centerX, centerY);

        firstCard = null;
        lockBoard = false;
      } else {
        mismatchSound.play();
        firstCard.classList.add("wrong");
        secondCard.classList.add("wrong");
        updateHearts(-1);

        setTimeout(() => {
          firstCard.classList.remove("flipped", "wrong");
          secondCard.classList.remove("flipped", "wrong");
          firstCard = null;
          lockBoard = false;
        }, CONFIG.WRONG_CARD_RESET_DELAY);

        if (hearts <= 0) {
          gameOverSound.play();
          showMessage("Game Over!");
          setTimeout(() => {
            stage = 1;
            startStage();
          }, CONFIG.STAGE_TRANSITION_DELAY);
          return;
        }
      }

      if (document.querySelectorAll(".matched").length === cards.length) {
        stageClearSound.play();
        showMessage(`Stage ${stage} Clear!`);
        createConfetti();
        if (stage === CONFIG.MAX_STAGES) {
          setTimeout(() => {
            showMessage("All Stages Cleared! Victory!");
            createVictoryParticles();
            stage = 1;
            setTimeout(() => startStage(), CONFIG.STAGE_TRANSITION_DELAY);
          }, CONFIG.STAGE_TRANSITION_DELAY);
        } else {
          stage += 1;
          setTimeout(() => startStage(), CONFIG.STAGE_TRANSITION_DELAY);
        }
      }
    }

    // Apply CONFIG to CSS dynamically
    const styleSheet = document.styleSheets[0];
    styleSheet.insertRule(`.card { transition: transform ${CONFIG.CARD_FLIP_DURATION / 1000}s; }`, styleSheet.cssRules.length);
    styleSheet.insertRule(`.card.wrong { animation: shake ${CONFIG.SHAKE_ANIMATION_DURATION / 1000}s; }`, styleSheet.cssRules.length);
    styleSheet.insertRule(`.card.matched .front { animation: glow ${CONFIG.GLOW_ANIMATION_DURATION / 1000}s infinite alternate; }`, styleSheet.cssRules.length);

    // Initial start
    startStage();
  </script>
</body>
</html>