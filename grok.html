<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Explosion Shooter - 화려한 폭발 게임</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 게임 변수
        let player = { x: width / 2, y: height - 100, width: 50, height: 30, color: '#00FFFF' }; // 플레이어 우주선
        let lasers = []; // 레이저 배열
        let enemies = []; // 적 배열
        let particles = []; // 파티클 배열
        let stars = []; // 배경 별 파티클
        let score = 0;
        let gameOver = false;
        let shakeTime = 0; // 화면 흔들림
        let flashTime = 0; // 플래시 효과

        // 사운드 (실제 URL로 교체)
        const shootSound = new Audio('data:audio/wav;base64,...'); // 쏘기 사운드
        const explodeSound = new Audio('data:audio/wav;base64,...'); // 폭발 사운드

        // 배경 별 생성
        for (let i = 0; i < 200; i++) {
            stars.push({ x: Math.random() * width, y: Math.random() * height, size: Math.random() * 2 + 1, speed: Math.random() * 2 + 1 });
        }

        // 파티클 생성 (빵빵 터지는 효과)
        function createParticles(x, y, count = 100, spread = 5, life = 50) {
            for (let i = 0; i < count; i++) {
                let angle = Math.random() * Math.PI * 2;
                let speed = Math.random() * spread + 2;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: life + Math.random() * 20,
                    size: Math.random() * 5 + 2,
                    color: `hsl(${Math.random() * 60 + 0}, 100%, ${Math.random() * 30 + 50}%)` // 불꽃 같은 색상
                });
            }
        }

        // 적 생성 (AI-like: 플레이어 향해 움직임)
        function generateEnemy() {
            if (gameOver) return;
            let enemy = { x: Math.random() * width, y: -50, width: 40, height: 40, vx: (Math.random() - 0.5) * 2, vy: 3 + Math.random() * 2, color: '#FF0000' };
            enemies.push(enemy);
            // AI: 간격으로 방향 조정 (플레이어 추적)
            setInterval(() => {
                if (enemy) {
                    let dx = player.x - enemy.x;
                    enemy.vx = dx / 100 + (Math.random() - 0.5); // 약간 랜덤 + 추적
                }
            }, 1000);
            setTimeout(generateEnemy, 1000 / (1 + score / 1000)); // 난이도 증가
        }

        // 입력 처리 (터치/마우스)
        let isShooting = false;
        canvas.addEventListener('touchstart', (e) => shoot(e.touches[0].clientX, e.touches[0].clientY));
        canvas.addEventListener('touchmove', (e) => { player.x = e.touches[0].clientX; }); // 플레이어 이동
        canvas.addEventListener('mousedown', (e) => shoot(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', (e) => { player.x = e.clientX; });

        function shoot(targetX, targetY) {
            if (gameOver || isShooting) return;
            isShooting = true;
            setTimeout(() => { isShooting = false; }, 200); // 발사 쿨타임
            lasers.push({ x: player.x, y: player.y - 20, width: 5, height: 20, vy: -10, color: '#00FF00', trail: [] });
            shootSound.play();
            createParticles(player.x, player.y - 20, 20, 2, 10); // 발사 효과
        }

        // 게임 루프
        function update() {
            // 배경 (우주 그라데이션 + 별 스크롤)
            let grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, '#000033');
            grad.addColorStop(1, '#000066');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            // 별 파티클 (반짝임)
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > height) star.y = 0;
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // 화면 흔들림/플래시
            if (shakeTime > 0) {
                ctx.save();
                ctx.translate(Math.random() * 10 - 5, Math.random() * 10 - 5);
                shakeTime--;
            }
            if (flashTime > 0) {
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = '#FF4500';
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 1;
                flashTime--;
            }

            // 플레이어
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y - player.height / 2);
            ctx.lineTo(player.x - player.width / 2, player.y + player.height / 2);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height / 2);
            ctx.closePath();
            ctx.fill();

            // 레이저 업데이트
            lasers.forEach((laser, i) => {
                laser.y += laser.vy;
                laser.trail.push({ x: laser.x, y: laser.y }); // 트레일
                if (laser.trail.length > 10) laser.trail.shift();
                if (laser.y < 0) lasers.splice(i, 1);

                // 트레일 그리기 (화려함)
                for (let j = 0; j < laser.trail.length; j++) {
                    ctx.fillStyle = `rgba(0, 255, 0, ${1 - j / laser.trail.length})`;
                    ctx.fillRect(laser.trail[j].x - 2, laser.trail[j].y, 4, 10);
                }
                ctx.fillStyle = laser.color;
                ctx.fillRect(laser.x - laser.width / 2, laser.y, laser.width, laser.height);
            });

            // 적 업데이트
            enemies.forEach((enemy, ei) => {
                enemy.x += enemy.vx;
                enemy.y += enemy.vy;
                if (enemy.y > height || enemy.x < 0 || enemy.x > width) enemies.splice(ei, 1);

                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.width / 2, 0, Math.PI * 2);
                ctx.fill();

                // 레이저 충돌
                lasers.forEach((laser, li) => {
                    if (Math.abs(laser.x - enemy.x) < enemy.width / 2 && Math.abs(laser.y - enemy.y) < enemy.height / 2) {
                        enemies.splice(ei, 1);
                        lasers.splice(li, 1);
                        createParticles(enemy.x, enemy.y, 150, 8, 60); // 빵빵 터지는 폭발!
                        explodeSound.play();
                        score += 10;
                        shakeTime = 10; // 화면 흔들림
                        flashTime = 5; // 플래시
                    }
                });

                // 플레이어 충돌
                if (Math.abs(player.x - enemy.x) < player.width / 2 + enemy.width / 2 && Math.abs(player.y - enemy.y) < player.height / 2 + enemy.height / 2) {
                    gameOver = true;
                    createParticles(player.x, player.y, 200, 10, 80); // 대폭발
                    shakeTime = 20;
                    flashTime = 10;
                }
            });

            // 파티클 업데이트 (화려한 효과 핵심)
            particles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.size *= 0.98; // 축소
                if (p.life < 0) particles.splice(i, 1);
                ctx.fillStyle = p.color.replace('100%', `${Math.max(0, p.life / 50 * 100)}%`); // 페이드 아웃
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // 스코어
            ctx.fillStyle = '#FFF';
            ctx.font = '30px Arial';
            ctx.fillText(`Score: ${score}`, width - 200, 50);

            if (shakeTime > 0) ctx.restore();

            if (!gameOver) requestAnimationFrame(update);
            else {
                ctx.fillStyle = '#FFF';
                ctx.font = '50px Arial';
                ctx.fillText('Game Over! Tap to Restart', width / 2 - 250, height / 2);
            }
        }

        // 게임 시작
        generateEnemy();
        update();

        // 재시작
        canvas.addEventListener('touchstart', () => {
            if (gameOver) {
                enemies = [];
                lasers = [];
                particles = [];
                score = 0;
                gameOver = false;
                generateEnemy();
                update();
            }
        });
        canvas.addEventListener('click', () => {
            if (gameOver) {
                enemies = [];
                lasers = [];
                particles = [];
                score = 0;
                gameOver = false;
                generateEnemy();
                update();
            }
        });
    </script>
</body>
</html>